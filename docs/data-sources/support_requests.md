---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "doit_support_requests Data Source - terraform-provider-doit"
subcategory: ""
description: |-
  Create and manage support tickets with DoiT.
---

# doit_support_requests (Data Source)

Create and manage support tickets with DoiT.

## Example Usage

```terraform
# List all support requests
data "doit_support_requests" "all" {
}

# Filter support requests by severity
data "doit_support_requests" "high_severity" {
  filter = "severity:high"
}

output "ticket_count" {
  value = data.doit_support_requests.all.row_count
}

# ─────────────────────────────────────────────────────────────────────────────
# Combining data sources: filter and enrich support requests
# ─────────────────────────────────────────────────────────────────────────────

# Use doit_users to find a specific user's email, then filter support requests
data "doit_users" "all" {}

# Filter support requests by a specific user from the users data source
# The filter syntax for requester is "requester:<email>"
output "tickets_by_user" {
  description = "Support tickets grouped by requester from the users data source"
  value = {
    for u in data.doit_users.all.users : u.email => [
      for t in data.doit_support_requests.all.tickets : {
        id       = t.id
        subject  = t.subject
        severity = t.severity
        status   = t.status
        platform = t.platform
      } if t.requester == u.email
      ] if length([
        for t in data.doit_support_requests.all.tickets : t if t.requester == u.email
    ]) > 0
  }
}

# Use doit_platforms to discover valid platform names for support request filtering
data "doit_platforms" "all" {}

output "tickets_by_platform" {
  description = "Support tickets grouped by platform"
  value = {
    for p in data.doit_platforms.all.platforms : p.display_name => [
      for t in data.doit_support_requests.all.tickets : {
        id       = t.id
        subject  = t.subject
        severity = t.severity
      } if t.platform == p.display_name
      ] if length([
        for t in data.doit_support_requests.all.tickets : t if t.platform == p.display_name
    ]) > 0
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `filter` (String) An expression for filtering the results of the request. The syntax is `key:[<value>]`. e.g: "severity:normal". Multiple filters can be
connected using a pipe |. Note that using different keys in the same
filter results in “AND,” while using the same key multiple times in
the same filter results in “OR”.
- `max_creation_time` (String) Max value for tickets creation time, in milliseconds since the POSIX epoch. If set, only tickets created before or at this timestamp are returned.
- `max_results` (Number) The maximum number of results to return in a single page. Leverage the page tokens to iterate through the entire collection.
- `min_creation_time` (String) Min value for tickets creation time, in milliseconds since the POSIX epoch. If set, only tickets created after or at this timestamp are returned.
- `page_token` (String) Page token, returned by a previous call, to request the next page of results

### Read-Only

- `row_count` (Number) Tickets rows count
- `tickets` (Attributes List) (see [below for nested schema](#nestedatt--tickets))

<a id="nestedatt--tickets"></a>
### Nested Schema for `tickets`

Read-Only:

- `create_time` (Number) The time when this ticket was created, in milliseconds since the epoch.
- `id` (Number) Ticket ID (e.g., "33234").
- `is_public` (Boolean) Whether the ticket is public.
- `platform` (String) Platform of the ticket.
- `product` (String) Ticket product.
- `requester` (String) The ticket requester in the form of user@domain.com
- `severity` (String) Ticket severity.
- `status` (String) Ticket status.
- `subject` (String) The subject of the ticket.
- `update_time` (Number) The time when this ticket was last updated, in milliseconds since the epoch.
- `url_ui` (String) Link to the report in DoiT console.
