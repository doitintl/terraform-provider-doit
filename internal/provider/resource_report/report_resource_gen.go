// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_report

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ReportResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"advanced_analysis": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"forecast": schema.BoolAttribute{
								Optional: true,
								Computed: true,
							},
							"not_trending": schema.BoolAttribute{
								Optional: true,
								Computed: true,
							},
							"trending_down": schema.BoolAttribute{
								Optional: true,
								Computed: true,
							},
							"trending_up": schema.BoolAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: AdvancedAnalysisType{
							ObjectType: types.ObjectType{
								AttrTypes: AdvancedAnalysisValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Advanced analysis options. Each of these can be set independently",
						MarkdownDescription: "Advanced analysis options. Each of these can be set independently",
					},
					"aggregation": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "How to aggregate data values in the report.\nPossible values: `total`, `percent_total`, `percent_col`, `percent_row`",
						MarkdownDescription: "How to aggregate data values in the report.\nPossible values: `total`, `percent_total`, `percent_col`, `percent_row`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"total",
								"percent_total",
								"percent_col",
								"percent_row",
							),
						},
					},
					"currency": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Currency code for monetary values.\nPossible values: `USD`, `ILS`, `EUR`, `AUD`, `CAD`, `GBP`, `DKK`, `NOK`, `SEK`, `BRL`, `SGD`, `MXN`, `CHF`, `MYR`, `TWD`, `EGP`, `ZAR`, `JPY`, `IDR`, `AED`, `THB`, `COP`",
						MarkdownDescription: "Currency code for monetary values.\nPossible values: `USD`, `ILS`, `EUR`, `AUD`, `CAD`, `GBP`, `DKK`, `NOK`, `SEK`, `BRL`, `SGD`, `MXN`, `CHF`, `MYR`, `TWD`, `EGP`, `ZAR`, `JPY`, `IDR`, `AED`, `THB`, `COP`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"USD",
								"ILS",
								"EUR",
								"AUD",
								"CAD",
								"GBP",
								"DKK",
								"NOK",
								"SEK",
								"BRL",
								"SGD",
								"MXN",
								"CHF",
								"MYR",
								"TWD",
								"EGP",
								"ZAR",
								"JPY",
								"IDR",
								"AED",
								"THB",
								"COP",
							),
						},
					},
					"custom_time_range": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"from": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The start timestamp of the time range in RFC3339 format.",
								MarkdownDescription: "The start timestamp of the time range in RFC3339 format.",
							},
							"to": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The end timestamp of the time range in RFC3339 format.",
								MarkdownDescription: "The end timestamp of the time range in RFC3339 format.",
							},
						},
						CustomType: CustomTimeRangeType{
							ObjectType: types.ObjectType{
								AttrTypes: CustomTimeRangeValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Required when the time range is set to \"custom\".",
						MarkdownDescription: "Required when the time range is set to \"custom\".",
					},
					"data_source": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Data source of the report.\nPossible values: `billing`, `bqlens`, `billing_datahub`, `kubernetes_utilization`",
						MarkdownDescription: "Data source of the report.\nPossible values: `billing`, `bqlens`, `billing_datahub`, `kubernetes_utilization`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"billing",
								"bqlens",
								"billing_datahub",
								"kubernetes_utilization",
							),
						},
					},
					"dimensions": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The field to apply to the dimension.",
									MarkdownDescription: "The field to apply to the dimension.",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Type of dimension or filter field.\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									MarkdownDescription: "Type of dimension or filter field.\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"datetime",
											"fixed",
											"optional",
											"label",
											"tag",
											"project_label",
											"system_label",
											"attribution",
											"attribution_group",
											"gke",
											"gke_label",
										),
									},
								},
							},
							CustomType: DimensionsType{
								ObjectType: types.ObjectType{
									AttrTypes: DimensionsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "See [Dimensions](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#dimensions).",
						MarkdownDescription: "See [Dimensions](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#dimensions).",
					},
					"display_values": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "See [View data as (Comparative report)](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#view-as).\nPossible values: `actuals_only`, `absolute_change`, `percentage_change`, `absolute_and_percentage`",
						MarkdownDescription: "See [View data as (Comparative report)](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#view-as).\nPossible values: `actuals_only`, `absolute_change`, `percentage_change`, `absolute_and_percentage`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"actuals_only",
								"absolute_change",
								"percentage_change",
								"absolute_and_percentage",
							),
						},
					},
					"filters": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Required:            true,
									Description:         "The field to filter on",
									MarkdownDescription: "The field to filter on",
								},
								"inverse": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Set to `true` to exclude the values.",
									MarkdownDescription: "Set to `true` to exclude the values.",
								},
								"mode": schema.StringAttribute{
									Required:            true,
									Description:         "Filter mode to apply\nPossible values: `is`, `starts_with`, `ends_with`, `contains`, `regexp`",
									MarkdownDescription: "Filter mode to apply\nPossible values: `is`, `starts_with`, `ends_with`, `contains`, `regexp`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"is",
											"starts_with",
											"ends_with",
											"contains",
											"regexp",
										),
									},
								},
								"type": schema.StringAttribute{
									Required:            true,
									Description:         "Type of dimension or filter field.\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									MarkdownDescription: "Type of dimension or filter field.\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"datetime",
											"fixed",
											"optional",
											"label",
											"tag",
											"project_label",
											"system_label",
											"attribution",
											"attribution_group",
											"gke",
											"gke_label",
										),
									},
								},
								"values": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "Values to filter on",
									MarkdownDescription: "Values to filter on",
								},
							},
							CustomType: FiltersType{
								ObjectType: types.ObjectType{
									AttrTypes: FiltersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The filters to apply to the report.",
						MarkdownDescription: "The filters to apply to the report.",
					},
					"group": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Dimension ID.",
									MarkdownDescription: "Dimension ID.",
								},
								"limit": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"metric": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Type of metric to use.\nPossible values: `basic`, `custom`, `extended`",
													MarkdownDescription: "Type of metric to use.\nPossible values: `basic`, `custom`, `extended`",
													Validators: []validator.String{
														stringvalidator.OneOf(
															"basic",
															"custom",
															"extended",
														),
													},
												},
												"value": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "For basic metrics, the value can be one of: [\"cost\", \"usage\", \"savings\"]\nIf using custom metrics, the value must refer to an existing custom id.",
													MarkdownDescription: "For basic metrics, the value can be one of: [\"cost\", \"usage\", \"savings\"]\nIf using custom metrics, the value must refer to an existing custom id.",
												},
											},
											CustomType: MetricType{
												ObjectType: types.ObjectType{
													AttrTypes: MetricValue{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "The metric to apply.",
											MarkdownDescription: "The metric to apply.",
										},
										"sort": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Sort order for ranking results.\nPossible values: `a_to_z`, `asc`, `desc`",
											MarkdownDescription: "Sort order for ranking results.\nPossible values: `a_to_z`, `asc`, `desc`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"a_to_z",
													"asc",
													"desc",
												),
											},
										},
										"value": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The number of items to show",
											MarkdownDescription: "The number of items to show",
										},
									},
									CustomType: LimitType{
										ObjectType: types.ObjectType{
											AttrTypes: LimitValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "To limit the number of results based on ranking. See [Limit by top/bottom](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#limit-by-topbottom).",
									MarkdownDescription: "To limit the number of results based on ranking. See [Limit by top/bottom](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#limit-by-topbottom).",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Type of dimension or filter field.\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									MarkdownDescription: "Type of dimension or filter field.\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"datetime",
											"fixed",
											"optional",
											"label",
											"tag",
											"project_label",
											"system_label",
											"attribution",
											"attribution_group",
											"gke",
											"gke_label",
										),
									},
								},
							},
							CustomType: GroupType{
								ObjectType: types.ObjectType{
									AttrTypes: GroupValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The rows that appear in the tabular format of the report. See [Group by](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#group-by).",
						MarkdownDescription: "The rows that appear in the tabular format of the report. See [Group by](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#group-by).",
					},
					"include_promotional_credits": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to include [promotional credits](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#promotional-credits).\nIf set to **true**, the report must use time interval `month`, `quarter`, or `year`.",
						MarkdownDescription: "Whether to include [promotional credits](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#promotional-credits).\nIf set to **true**, the report must use time interval `month`, `quarter`, or `year`.",
					},
					"include_subtotals": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to include subgroup totals in the report. This option has no impact when reading a report via API.",
						MarkdownDescription: "Whether to include subgroup totals in the report. This option has no impact when reading a report via API.",
						Default:             booldefault.StaticBool(false),
					},
					"layout": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The visualization of the report.\nPossible values: `column_chart`, `stacked_column_chart`, `bar_chart`, `stacked_bar_chart`, `line_chart`, `spline_chart`, `area_chart`, `area_spline_chart`, `stacked_area_chart`, `treemap_chart`, `table`, `table_heatmap`, `table_row_heatmap`, `table_col_heatmap`, `csv_export`, `sheets_export`",
						MarkdownDescription: "The visualization of the report.\nPossible values: `column_chart`, `stacked_column_chart`, `bar_chart`, `stacked_bar_chart`, `line_chart`, `spline_chart`, `area_chart`, `area_spline_chart`, `stacked_area_chart`, `treemap_chart`, `table`, `table_heatmap`, `table_row_heatmap`, `table_col_heatmap`, `csv_export`, `sheets_export`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"column_chart",
								"stacked_column_chart",
								"bar_chart",
								"stacked_bar_chart",
								"line_chart",
								"spline_chart",
								"area_chart",
								"area_spline_chart",
								"stacked_area_chart",
								"treemap_chart",
								"table",
								"table_heatmap",
								"table_row_heatmap",
								"table_col_heatmap",
								"csv_export",
								"sheets_export",
							),
						},
					},
					"metric": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Type of metric to use.\nPossible values: `basic`, `custom`, `extended`",
								MarkdownDescription: "Type of metric to use.\nPossible values: `basic`, `custom`, `extended`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"basic",
										"custom",
										"extended",
									),
								},
							},
							"value": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "For basic metrics, the value can be one of: [\"cost\", \"usage\", \"savings\"]\nIf using custom metrics, the value must refer to an existing custom id.",
								MarkdownDescription: "For basic metrics, the value can be one of: [\"cost\", \"usage\", \"savings\"]\nIf using custom metrics, the value must refer to an existing custom id.",
							},
						},
						CustomType: MetricType{
							ObjectType: types.ObjectType{
								AttrTypes: MetricValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The metric to apply.",
						MarkdownDescription: "The metric to apply.",
					},
					"metric_filter": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"metric": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Type of metric to use.\nPossible values: `basic`, `custom`, `extended`",
										MarkdownDescription: "Type of metric to use.\nPossible values: `basic`, `custom`, `extended`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"basic",
												"custom",
												"extended",
											),
										},
									},
									"value": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "For basic metrics, the value can be one of: [\"cost\", \"usage\", \"savings\"]\nIf using custom metrics, the value must refer to an existing custom id.",
										MarkdownDescription: "For basic metrics, the value can be one of: [\"cost\", \"usage\", \"savings\"]\nIf using custom metrics, the value must refer to an existing custom id.",
									},
								},
								CustomType: MetricType{
									ObjectType: types.ObjectType{
										AttrTypes: MetricValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "The metric to apply.",
								MarkdownDescription: "The metric to apply.",
							},
							"operator": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Comparison operator for filtering metric values.\nPossible values: `gt`, `lt`, `lte`, `gte`, `b`, `nb`, `e`, `ne`",
								MarkdownDescription: "Comparison operator for filtering metric values.\nPossible values: `gt`, `lt`, `lte`, `gte`, `b`, `nb`, `e`, `ne`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gt",
										"lt",
										"lte",
										"gte",
										"b",
										"nb",
										"e",
										"ne",
									),
								},
							},
							"values": schema.ListAttribute{
								ElementType: types.Float64Type,
								Optional:    true,
								Computed:    true,
							},
						},
						CustomType: MetricFilterType{
							ObjectType: types.ObjectType{
								AttrTypes: MetricFilterValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The metric filter to limit the report results by value",
						MarkdownDescription: "The metric filter to limit the report results by value",
					},
					"sort_dimensions": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "This option has no impact when reading reports via API.\nPossible values: `asc`, `desc`, `a_to_z`",
						MarkdownDescription: "This option has no impact when reading reports via API.\nPossible values: `asc`, `desc`, `a_to_z`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"asc",
								"desc",
								"a_to_z",
							),
						},
						Default: stringdefault.StaticString("desc"),
					},
					"sort_groups": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "This option has no impact when reading reports via API.\nPossible values: `asc`, `desc`, `a_to_z`",
						MarkdownDescription: "This option has no impact when reading reports via API.\nPossible values: `asc`, `desc`, `a_to_z`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"asc",
								"desc",
								"a_to_z",
							),
						},
						Default: stringdefault.StaticString("asc"),
					},
					"splits": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "ID of the field to split",
									MarkdownDescription: "ID of the field to split",
								},
								"include_origin": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if set, include the origin",
									MarkdownDescription: "if set, include the origin",
								},
								"mode": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Possible values: `even`, `custom`, `proportional`",
									MarkdownDescription: "Possible values: `even`, `custom`, `proportional`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"even",
											"custom",
											"proportional",
										),
									},
								},
								"origin": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "ID of the origin",
											MarkdownDescription: "ID of the origin",
										},
										"type": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Type of the origin.\nThe only supported values at the moment: \"attribution\", \"unallocated\"\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`, `unallocated`",
											MarkdownDescription: "Type of the origin.\nThe only supported values at the moment: \"attribution\", \"unallocated\"\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`, `unallocated`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"datetime",
													"fixed",
													"optional",
													"label",
													"tag",
													"project_label",
													"system_label",
													"attribution",
													"attribution_group",
													"gke",
													"gke_label",
													"unallocated",
												),
											},
										},
									},
									CustomType: OriginType{
										ObjectType: types.ObjectType{
											AttrTypes: OriginValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
									Computed: true,
								},
								"targets": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "ID of the target",
												MarkdownDescription: "ID of the target",
											},
											"type": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Type of the target.\nThe only supported value at the moment: \"attribution\"\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
												MarkdownDescription: "Type of the target.\nThe only supported value at the moment: \"attribution\"\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"datetime",
														"fixed",
														"optional",
														"label",
														"tag",
														"project_label",
														"system_label",
														"attribution",
														"attribution_group",
														"gke",
														"gke_label",
													),
												},
											},
											"value": schema.Float64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Percent of the target, represented in float format. E.g. 30% is 0.3. Must be set only if Split Mode is custom.",
												MarkdownDescription: "Percent of the target, represented in float format. E.g. 30% is 0.3. Must be set only if Split Mode is custom.",
											},
										},
										CustomType: TargetsType{
											ObjectType: types.ObjectType{
												AttrTypes: TargetsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Targets for the split",
									MarkdownDescription: "Targets for the split",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Type of the split.\nThe only supported value at the moment: \"attribution_group\"\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									MarkdownDescription: "Type of the split.\nThe only supported value at the moment: \"attribution_group\"\nPossible values: `datetime`, `fixed`, `optional`, `label`, `tag`, `project_label`, `system_label`, `attribution`, `attribution_group`, `gke`, `gke_label`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"datetime",
											"fixed",
											"optional",
											"label",
											"tag",
											"project_label",
											"system_label",
											"attribution",
											"attribution_group",
											"gke",
											"gke_label",
										),
									},
								},
							},
							CustomType: SplitsType{
								ObjectType: types.ObjectType{
									AttrTypes: SplitsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The splits to use in the report.",
						MarkdownDescription: "The splits to use in the report.",
					},
					"time_interval": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Time interval for grouping data in the report.\nPossible values: `hour`, `day`, `dayCumSum`, `week`, `isoweek`, `month`, `quarter`, `year`, `week_day`",
						MarkdownDescription: "Time interval for grouping data in the report.\nPossible values: `hour`, `day`, `dayCumSum`, `week`, `isoweek`, `month`, `quarter`, `year`, `week_day`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"hour",
								"day",
								"dayCumSum",
								"week",
								"isoweek",
								"month",
								"quarter",
								"year",
								"week_day",
							),
						},
					},
					"time_range": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"amount": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Number of time units to include in the time range.",
								MarkdownDescription: "Number of time units to include in the time range.",
								Validators: []validator.Int64{
									int64validator.Between(0, 5000),
								},
							},
							"include_current": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Whether to include the current time period.",
								MarkdownDescription: "Whether to include the current time period.",
							},
							"mode": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Time range mode (last N periods, current period, or custom).\nPossible values: `last`, `current`, `custom`",
								MarkdownDescription: "Time range mode (last N periods, current period, or custom).\nPossible values: `last`, `current`, `custom`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"last",
										"current",
										"custom",
									),
								},
							},
							"unit": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Time unit for the time range.\nPossible values: `day`, `week`, `month`, `quarter`, `year`",
								MarkdownDescription: "Time unit for the time range.\nPossible values: `day`, `week`, `month`, `quarter`, `year`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"day",
										"week",
										"month",
										"quarter",
										"year",
									),
								},
							},
						},
						CustomType: TimeRangeType{
							ObjectType: types.ObjectType{
								AttrTypes: TimeRangeValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Specify a predefined or custom time range for the report.\nFor example, to specify a custom time range of \"last 2 days\", set the mode to `last`, the amount to `2`, and the unit to `day`. If `includeCurrent` is `true`, the range will be yesterday and today; otherwise, the range will be yesterday and the day before yesterday.\nIf \"custom\" type is specified, you need to provide a custom time range in the `customTimeRange` field.",
						MarkdownDescription: "Specify a predefined or custom time range for the report.\nFor example, to specify a custom time range of \"last 2 days\", set the mode to `last`, the amount to `2`, and the unit to `day`. If `includeCurrent` is `true`, the range will be yesterday and today; otherwise, the range will be yesterday and the day before yesterday.\nIf \"custom\" type is specified, you need to provide a custom time range in the `customTimeRange` field.",
					},
				},
				CustomType: ConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: ConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Report configuration",
				MarkdownDescription: "Report configuration",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Report description.",
				MarkdownDescription: "Report description.",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "ID of the new report.",
				MarkdownDescription: "ID of the new report.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Report name.",
				MarkdownDescription: "Report name.",
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "Report type.",
				MarkdownDescription: "Report type.",
			},
		},
		Description:         "Reports provide detailed analysis and visualization of your cloud costs. You can create custom reports with various dimensions, metrics, and filters.",
		MarkdownDescription: "Reports provide detailed analysis and visualization of your cloud costs. You can create custom reports with various dimensions, metrics, and filters.",
	}
}

type ReportModel struct {
	Config      ConfigValue  `tfsdk:"config"`
	Description types.String `tfsdk:"description"`
	Id          types.String `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Type        types.String `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advancedAnalysisAttribute, ok := attributes["advanced_analysis"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advanced_analysis is missing from object`)

		return nil, diags
	}

	advancedAnalysisVal, ok := advancedAnalysisAttribute.(AdvancedAnalysisValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advanced_analysis expected to be AdvancedAnalysisValue, was: %T`, advancedAnalysisAttribute))
	}

	aggregationAttribute, ok := attributes["aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation is missing from object`)

		return nil, diags
	}

	aggregationVal, ok := aggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation expected to be basetypes.StringValue, was: %T`, aggregationAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customTimeRangeAttribute, ok := attributes["custom_time_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_time_range is missing from object`)

		return nil, diags
	}

	customTimeRangeVal, ok := customTimeRangeAttribute.(CustomTimeRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_time_range expected to be CustomTimeRangeValue, was: %T`, customTimeRangeAttribute))
	}

	dataSourceAttribute, ok := attributes["data_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_source is missing from object`)

		return nil, diags
	}

	dataSourceVal, ok := dataSourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_source expected to be basetypes.StringValue, was: %T`, dataSourceAttribute))
	}

	dimensionsAttribute, ok := attributes["dimensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dimensions is missing from object`)

		return nil, diags
	}

	dimensionsVal, ok := dimensionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dimensions expected to be basetypes.ListValue, was: %T`, dimensionsAttribute))
	}

	displayValuesAttribute, ok := attributes["display_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_values is missing from object`)

		return nil, diags
	}

	displayValuesVal, ok := displayValuesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_values expected to be basetypes.StringValue, was: %T`, displayValuesAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.ListValue, was: %T`, groupAttribute))
	}

	includePromotionalCreditsAttribute, ok := attributes["include_promotional_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_promotional_credits is missing from object`)

		return nil, diags
	}

	includePromotionalCreditsVal, ok := includePromotionalCreditsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_promotional_credits expected to be basetypes.BoolValue, was: %T`, includePromotionalCreditsAttribute))
	}

	includeSubtotalsAttribute, ok := attributes["include_subtotals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_subtotals is missing from object`)

		return nil, diags
	}

	includeSubtotalsVal, ok := includeSubtotalsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_subtotals expected to be basetypes.BoolValue, was: %T`, includeSubtotalsAttribute))
	}

	layoutAttribute, ok := attributes["layout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layout is missing from object`)

		return nil, diags
	}

	layoutVal, ok := layoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layout expected to be basetypes.StringValue, was: %T`, layoutAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(MetricValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be MetricValue, was: %T`, metricAttribute))
	}

	metricFilterAttribute, ok := attributes["metric_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_filter is missing from object`)

		return nil, diags
	}

	metricFilterVal, ok := metricFilterAttribute.(MetricFilterValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_filter expected to be MetricFilterValue, was: %T`, metricFilterAttribute))
	}

	sortDimensionsAttribute, ok := attributes["sort_dimensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sort_dimensions is missing from object`)

		return nil, diags
	}

	sortDimensionsVal, ok := sortDimensionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sort_dimensions expected to be basetypes.StringValue, was: %T`, sortDimensionsAttribute))
	}

	sortGroupsAttribute, ok := attributes["sort_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sort_groups is missing from object`)

		return nil, diags
	}

	sortGroupsVal, ok := sortGroupsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sort_groups expected to be basetypes.StringValue, was: %T`, sortGroupsAttribute))
	}

	splitsAttribute, ok := attributes["splits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`splits is missing from object`)

		return nil, diags
	}

	splitsVal, ok := splitsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`splits expected to be basetypes.ListValue, was: %T`, splitsAttribute))
	}

	timeIntervalAttribute, ok := attributes["time_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_interval is missing from object`)

		return nil, diags
	}

	timeIntervalVal, ok := timeIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_interval expected to be basetypes.StringValue, was: %T`, timeIntervalAttribute))
	}

	timeRangeAttribute, ok := attributes["time_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_range is missing from object`)

		return nil, diags
	}

	timeRangeVal, ok := timeRangeAttribute.(TimeRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_range expected to be TimeRangeValue, was: %T`, timeRangeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		AdvancedAnalysis:          advancedAnalysisVal,
		Aggregation:               aggregationVal,
		Currency:                  currencyVal,
		CustomTimeRange:           customTimeRangeVal,
		DataSource:                dataSourceVal,
		Dimensions:                dimensionsVal,
		DisplayValues:             displayValuesVal,
		Filters:                   filtersVal,
		Group:                     groupVal,
		IncludePromotionalCredits: includePromotionalCreditsVal,
		IncludeSubtotals:          includeSubtotalsVal,
		Layout:                    layoutVal,
		Metric:                    metricVal,
		MetricFilter:              metricFilterVal,
		SortDimensions:            sortDimensionsVal,
		SortGroups:                sortGroupsVal,
		Splits:                    splitsVal,
		TimeInterval:              timeIntervalVal,
		TimeRange:                 timeRangeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	advancedAnalysisAttribute, ok := attributes["advanced_analysis"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advanced_analysis is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	advancedAnalysisVal, ok := advancedAnalysisAttribute.(AdvancedAnalysisValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advanced_analysis expected to be AdvancedAnalysisValue, was: %T`, advancedAnalysisAttribute))
	}

	aggregationAttribute, ok := attributes["aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	aggregationVal, ok := aggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation expected to be basetypes.StringValue, was: %T`, aggregationAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customTimeRangeAttribute, ok := attributes["custom_time_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_time_range is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	customTimeRangeVal, ok := customTimeRangeAttribute.(CustomTimeRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_time_range expected to be CustomTimeRangeValue, was: %T`, customTimeRangeAttribute))
	}

	dataSourceAttribute, ok := attributes["data_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_source is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dataSourceVal, ok := dataSourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_source expected to be basetypes.StringValue, was: %T`, dataSourceAttribute))
	}

	dimensionsAttribute, ok := attributes["dimensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dimensions is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dimensionsVal, ok := dimensionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dimensions expected to be basetypes.ListValue, was: %T`, dimensionsAttribute))
	}

	displayValuesAttribute, ok := attributes["display_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_values is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	displayValuesVal, ok := displayValuesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_values expected to be basetypes.StringValue, was: %T`, displayValuesAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.ListValue, was: %T`, groupAttribute))
	}

	includePromotionalCreditsAttribute, ok := attributes["include_promotional_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_promotional_credits is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	includePromotionalCreditsVal, ok := includePromotionalCreditsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_promotional_credits expected to be basetypes.BoolValue, was: %T`, includePromotionalCreditsAttribute))
	}

	includeSubtotalsAttribute, ok := attributes["include_subtotals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_subtotals is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	includeSubtotalsVal, ok := includeSubtotalsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_subtotals expected to be basetypes.BoolValue, was: %T`, includeSubtotalsAttribute))
	}

	layoutAttribute, ok := attributes["layout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layout is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	layoutVal, ok := layoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layout expected to be basetypes.StringValue, was: %T`, layoutAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(MetricValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be MetricValue, was: %T`, metricAttribute))
	}

	metricFilterAttribute, ok := attributes["metric_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_filter is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	metricFilterVal, ok := metricFilterAttribute.(MetricFilterValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_filter expected to be MetricFilterValue, was: %T`, metricFilterAttribute))
	}

	sortDimensionsAttribute, ok := attributes["sort_dimensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sort_dimensions is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	sortDimensionsVal, ok := sortDimensionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sort_dimensions expected to be basetypes.StringValue, was: %T`, sortDimensionsAttribute))
	}

	sortGroupsAttribute, ok := attributes["sort_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sort_groups is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	sortGroupsVal, ok := sortGroupsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sort_groups expected to be basetypes.StringValue, was: %T`, sortGroupsAttribute))
	}

	splitsAttribute, ok := attributes["splits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`splits is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	splitsVal, ok := splitsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`splits expected to be basetypes.ListValue, was: %T`, splitsAttribute))
	}

	timeIntervalAttribute, ok := attributes["time_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_interval is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	timeIntervalVal, ok := timeIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_interval expected to be basetypes.StringValue, was: %T`, timeIntervalAttribute))
	}

	timeRangeAttribute, ok := attributes["time_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_range is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	timeRangeVal, ok := timeRangeAttribute.(TimeRangeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_range expected to be TimeRangeValue, was: %T`, timeRangeAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		AdvancedAnalysis:          advancedAnalysisVal,
		Aggregation:               aggregationVal,
		Currency:                  currencyVal,
		CustomTimeRange:           customTimeRangeVal,
		DataSource:                dataSourceVal,
		Dimensions:                dimensionsVal,
		DisplayValues:             displayValuesVal,
		Filters:                   filtersVal,
		Group:                     groupVal,
		IncludePromotionalCredits: includePromotionalCreditsVal,
		IncludeSubtotals:          includeSubtotalsVal,
		Layout:                    layoutVal,
		Metric:                    metricVal,
		MetricFilter:              metricFilterVal,
		SortDimensions:            sortDimensionsVal,
		SortGroups:                sortGroupsVal,
		Splits:                    splitsVal,
		TimeInterval:              timeIntervalVal,
		TimeRange:                 timeRangeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	AdvancedAnalysis          AdvancedAnalysisValue `tfsdk:"advanced_analysis"`
	Aggregation               basetypes.StringValue `tfsdk:"aggregation"`
	Currency                  basetypes.StringValue `tfsdk:"currency"`
	CustomTimeRange           CustomTimeRangeValue  `tfsdk:"custom_time_range"`
	DataSource                basetypes.StringValue `tfsdk:"data_source"`
	Dimensions                basetypes.ListValue   `tfsdk:"dimensions"`
	DisplayValues             basetypes.StringValue `tfsdk:"display_values"`
	Filters                   basetypes.ListValue   `tfsdk:"filters"`
	Group                     basetypes.ListValue   `tfsdk:"group"`
	IncludePromotionalCredits basetypes.BoolValue   `tfsdk:"include_promotional_credits"`
	IncludeSubtotals          basetypes.BoolValue   `tfsdk:"include_subtotals"`
	Layout                    basetypes.StringValue `tfsdk:"layout"`
	Metric                    MetricValue           `tfsdk:"metric"`
	MetricFilter              MetricFilterValue     `tfsdk:"metric_filter"`
	SortDimensions            basetypes.StringValue `tfsdk:"sort_dimensions"`
	SortGroups                basetypes.StringValue `tfsdk:"sort_groups"`
	Splits                    basetypes.ListValue   `tfsdk:"splits"`
	TimeInterval              basetypes.StringValue `tfsdk:"time_interval"`
	TimeRange                 TimeRangeValue        `tfsdk:"time_range"`
	state                     attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 19)

	var val tftypes.Value
	var err error

	attrTypes["advanced_analysis"] = AdvancedAnalysisType{
		basetypes.ObjectType{
			AttrTypes: AdvancedAnalysisValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_time_range"] = CustomTimeRangeType{
		basetypes.ObjectType{
			AttrTypes: CustomTimeRangeValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["data_source"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dimensions"] = basetypes.ListType{
		ElemType: DimensionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["display_values"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["group"] = basetypes.ListType{
		ElemType: GroupValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["include_promotional_credits"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["include_subtotals"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["layout"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metric"] = MetricType{
		basetypes.ObjectType{
			AttrTypes: MetricValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["metric_filter"] = MetricFilterType{
		basetypes.ObjectType{
			AttrTypes: MetricFilterValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["sort_dimensions"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sort_groups"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["splits"] = basetypes.ListType{
		ElemType: SplitsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["time_interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["time_range"] = TimeRangeType{
		basetypes.ObjectType{
			AttrTypes: TimeRangeValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 19)

		val, err = v.AdvancedAnalysis.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advanced_analysis"] = val

		val, err = v.Aggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregation"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.CustomTimeRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_time_range"] = val

		val, err = v.DataSource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_source"] = val

		val, err = v.Dimensions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dimensions"] = val

		val, err = v.DisplayValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_values"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.IncludePromotionalCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_promotional_credits"] = val

		val, err = v.IncludeSubtotals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_subtotals"] = val

		val, err = v.Layout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["layout"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.MetricFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric_filter"] = val

		val, err = v.SortDimensions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sort_dimensions"] = val

		val, err = v.SortGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sort_groups"] = val

		val, err = v.Splits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["splits"] = val

		val, err = v.TimeInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_interval"] = val

		val, err = v.TimeRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_range"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var advancedAnalysis attr.Value

	{
		advancedAnalysis = v.AdvancedAnalysis
	}

	var customTimeRange attr.Value

	{
		customTimeRange = v.CustomTimeRange
	}

	var dimensions attr.Value

	{
		dimensions = v.Dimensions
	}

	var filters attr.Value

	{
		filters = v.Filters
	}

	var group attr.Value

	{
		group = v.Group
	}

	var metric attr.Value

	{
		metric = v.Metric
	}

	var metricFilter attr.Value

	{
		metricFilter = v.MetricFilter
	}

	var splits attr.Value

	{
		splits = v.Splits
	}

	var timeRange attr.Value

	{
		timeRange = v.TimeRange
	}

	attributeTypes := map[string]attr.Type{
		"advanced_analysis": AdvancedAnalysisType{
			basetypes.ObjectType{
				AttrTypes: AdvancedAnalysisValue{}.AttributeTypes(ctx),
			},
		},
		"aggregation": basetypes.StringType{},
		"currency":    basetypes.StringType{},
		"custom_time_range": CustomTimeRangeType{
			basetypes.ObjectType{
				AttrTypes: CustomTimeRangeValue{}.AttributeTypes(ctx),
			},
		},
		"data_source": basetypes.StringType{},
		"dimensions": basetypes.ListType{
			ElemType: DimensionsValue{}.Type(ctx),
		},
		"display_values": basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"group": basetypes.ListType{
			ElemType: GroupValue{}.Type(ctx),
		},
		"include_promotional_credits": basetypes.BoolType{},
		"include_subtotals":           basetypes.BoolType{},
		"layout":                      basetypes.StringType{},
		"metric": MetricType{
			basetypes.ObjectType{
				AttrTypes: MetricValue{}.AttributeTypes(ctx),
			},
		},
		"metric_filter": MetricFilterType{
			basetypes.ObjectType{
				AttrTypes: MetricFilterValue{}.AttributeTypes(ctx),
			},
		},
		"sort_dimensions": basetypes.StringType{},
		"sort_groups":     basetypes.StringType{},
		"splits": basetypes.ListType{
			ElemType: SplitsValue{}.Type(ctx),
		},
		"time_interval": basetypes.StringType{},
		"time_range": TimeRangeType{
			basetypes.ObjectType{
				AttrTypes: TimeRangeValue{}.AttributeTypes(ctx),
			},
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advanced_analysis":           advancedAnalysis,
			"aggregation":                 v.Aggregation,
			"currency":                    v.Currency,
			"custom_time_range":           customTimeRange,
			"data_source":                 v.DataSource,
			"dimensions":                  dimensions,
			"display_values":              v.DisplayValues,
			"filters":                     filters,
			"group":                       group,
			"include_promotional_credits": v.IncludePromotionalCredits,
			"include_subtotals":           v.IncludeSubtotals,
			"layout":                      v.Layout,
			"metric":                      metric,
			"metric_filter":               metricFilter,
			"sort_dimensions":             v.SortDimensions,
			"sort_groups":                 v.SortGroups,
			"splits":                      splits,
			"time_interval":               v.TimeInterval,
			"time_range":                  timeRange,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvancedAnalysis.Equal(other.AdvancedAnalysis) {
		return false
	}

	if !v.Aggregation.Equal(other.Aggregation) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.CustomTimeRange.Equal(other.CustomTimeRange) {
		return false
	}

	if !v.DataSource.Equal(other.DataSource) {
		return false
	}

	if !v.Dimensions.Equal(other.Dimensions) {
		return false
	}

	if !v.DisplayValues.Equal(other.DisplayValues) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.IncludePromotionalCredits.Equal(other.IncludePromotionalCredits) {
		return false
	}

	if !v.IncludeSubtotals.Equal(other.IncludeSubtotals) {
		return false
	}

	if !v.Layout.Equal(other.Layout) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.MetricFilter.Equal(other.MetricFilter) {
		return false
	}

	if !v.SortDimensions.Equal(other.SortDimensions) {
		return false
	}

	if !v.SortGroups.Equal(other.SortGroups) {
		return false
	}

	if !v.Splits.Equal(other.Splits) {
		return false
	}

	if !v.TimeInterval.Equal(other.TimeInterval) {
		return false
	}

	if !v.TimeRange.Equal(other.TimeRange) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advanced_analysis": AdvancedAnalysisType{
			basetypes.ObjectType{
				AttrTypes: AdvancedAnalysisValue{}.AttributeTypes(ctx),
			},
		},
		"aggregation": basetypes.StringType{},
		"currency":    basetypes.StringType{},
		"custom_time_range": CustomTimeRangeType{
			basetypes.ObjectType{
				AttrTypes: CustomTimeRangeValue{}.AttributeTypes(ctx),
			},
		},
		"data_source": basetypes.StringType{},
		"dimensions": basetypes.ListType{
			ElemType: DimensionsValue{}.Type(ctx),
		},
		"display_values": basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"group": basetypes.ListType{
			ElemType: GroupValue{}.Type(ctx),
		},
		"include_promotional_credits": basetypes.BoolType{},
		"include_subtotals":           basetypes.BoolType{},
		"layout":                      basetypes.StringType{},
		"metric": MetricType{
			basetypes.ObjectType{
				AttrTypes: MetricValue{}.AttributeTypes(ctx),
			},
		},
		"metric_filter": MetricFilterType{
			basetypes.ObjectType{
				AttrTypes: MetricFilterValue{}.AttributeTypes(ctx),
			},
		},
		"sort_dimensions": basetypes.StringType{},
		"sort_groups":     basetypes.StringType{},
		"splits": basetypes.ListType{
			ElemType: SplitsValue{}.Type(ctx),
		},
		"time_interval": basetypes.StringType{},
		"time_range": TimeRangeType{
			basetypes.ObjectType{
				AttrTypes: TimeRangeValue{}.AttributeTypes(ctx),
			},
		},
	}
}

var _ basetypes.ObjectTypable = AdvancedAnalysisType{}

type AdvancedAnalysisType struct {
	basetypes.ObjectType
}

func (t AdvancedAnalysisType) Equal(o attr.Type) bool {
	other, ok := o.(AdvancedAnalysisType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AdvancedAnalysisType) String() string {
	return "AdvancedAnalysisType"
}

func (t AdvancedAnalysisType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	forecastAttribute, ok := attributes["forecast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forecast is missing from object`)

		return nil, diags
	}

	forecastVal, ok := forecastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forecast expected to be basetypes.BoolValue, was: %T`, forecastAttribute))
	}

	notTrendingAttribute, ok := attributes["not_trending"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_trending is missing from object`)

		return nil, diags
	}

	notTrendingVal, ok := notTrendingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_trending expected to be basetypes.BoolValue, was: %T`, notTrendingAttribute))
	}

	trendingDownAttribute, ok := attributes["trending_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trending_down is missing from object`)

		return nil, diags
	}

	trendingDownVal, ok := trendingDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trending_down expected to be basetypes.BoolValue, was: %T`, trendingDownAttribute))
	}

	trendingUpAttribute, ok := attributes["trending_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trending_up is missing from object`)

		return nil, diags
	}

	trendingUpVal, ok := trendingUpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trending_up expected to be basetypes.BoolValue, was: %T`, trendingUpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AdvancedAnalysisValue{
		Forecast:     forecastVal,
		NotTrending:  notTrendingVal,
		TrendingDown: trendingDownVal,
		TrendingUp:   trendingUpVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewAdvancedAnalysisValueNull() AdvancedAnalysisValue {
	return AdvancedAnalysisValue{
		state: attr.ValueStateNull,
	}
}

func NewAdvancedAnalysisValueUnknown() AdvancedAnalysisValue {
	return AdvancedAnalysisValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAdvancedAnalysisValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AdvancedAnalysisValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AdvancedAnalysisValue Attribute Value",
				"While creating a AdvancedAnalysisValue value, a missing attribute value was detected. "+
					"A AdvancedAnalysisValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdvancedAnalysisValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AdvancedAnalysisValue Attribute Type",
				"While creating a AdvancedAnalysisValue value, an invalid attribute value was detected. "+
					"A AdvancedAnalysisValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdvancedAnalysisValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AdvancedAnalysisValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AdvancedAnalysisValue Attribute Value",
				"While creating a AdvancedAnalysisValue value, an extra attribute value was detected. "+
					"A AdvancedAnalysisValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AdvancedAnalysisValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAdvancedAnalysisValueUnknown(), diags
	}

	forecastAttribute, ok := attributes["forecast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forecast is missing from object`)

		return NewAdvancedAnalysisValueUnknown(), diags
	}

	forecastVal, ok := forecastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forecast expected to be basetypes.BoolValue, was: %T`, forecastAttribute))
	}

	notTrendingAttribute, ok := attributes["not_trending"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_trending is missing from object`)

		return NewAdvancedAnalysisValueUnknown(), diags
	}

	notTrendingVal, ok := notTrendingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_trending expected to be basetypes.BoolValue, was: %T`, notTrendingAttribute))
	}

	trendingDownAttribute, ok := attributes["trending_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trending_down is missing from object`)

		return NewAdvancedAnalysisValueUnknown(), diags
	}

	trendingDownVal, ok := trendingDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trending_down expected to be basetypes.BoolValue, was: %T`, trendingDownAttribute))
	}

	trendingUpAttribute, ok := attributes["trending_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trending_up is missing from object`)

		return NewAdvancedAnalysisValueUnknown(), diags
	}

	trendingUpVal, ok := trendingUpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trending_up expected to be basetypes.BoolValue, was: %T`, trendingUpAttribute))
	}

	if diags.HasError() {
		return NewAdvancedAnalysisValueUnknown(), diags
	}

	return AdvancedAnalysisValue{
		Forecast:     forecastVal,
		NotTrending:  notTrendingVal,
		TrendingDown: trendingDownVal,
		TrendingUp:   trendingUpVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewAdvancedAnalysisValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AdvancedAnalysisValue {
	object, diags := NewAdvancedAnalysisValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAdvancedAnalysisValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AdvancedAnalysisType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAdvancedAnalysisValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAdvancedAnalysisValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAdvancedAnalysisValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAdvancedAnalysisValueMust(AdvancedAnalysisValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AdvancedAnalysisType) ValueType(ctx context.Context) attr.Value {
	return AdvancedAnalysisValue{}
}

var _ basetypes.ObjectValuable = AdvancedAnalysisValue{}

type AdvancedAnalysisValue struct {
	Forecast     basetypes.BoolValue `tfsdk:"forecast"`
	NotTrending  basetypes.BoolValue `tfsdk:"not_trending"`
	TrendingDown basetypes.BoolValue `tfsdk:"trending_down"`
	TrendingUp   basetypes.BoolValue `tfsdk:"trending_up"`
	state        attr.ValueState
}

func (v AdvancedAnalysisValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["forecast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["not_trending"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["trending_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["trending_up"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Forecast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forecast"] = val

		val, err = v.NotTrending.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_trending"] = val

		val, err = v.TrendingDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trending_down"] = val

		val, err = v.TrendingUp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trending_up"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AdvancedAnalysisValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AdvancedAnalysisValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AdvancedAnalysisValue) String() string {
	return "AdvancedAnalysisValue"
}

func (v AdvancedAnalysisValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"forecast":      basetypes.BoolType{},
		"not_trending":  basetypes.BoolType{},
		"trending_down": basetypes.BoolType{},
		"trending_up":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"forecast":      v.Forecast,
			"not_trending":  v.NotTrending,
			"trending_down": v.TrendingDown,
			"trending_up":   v.TrendingUp,
		})

	return objVal, diags
}

func (v AdvancedAnalysisValue) Equal(o attr.Value) bool {
	other, ok := o.(AdvancedAnalysisValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Forecast.Equal(other.Forecast) {
		return false
	}

	if !v.NotTrending.Equal(other.NotTrending) {
		return false
	}

	if !v.TrendingDown.Equal(other.TrendingDown) {
		return false
	}

	if !v.TrendingUp.Equal(other.TrendingUp) {
		return false
	}

	return true
}

func (v AdvancedAnalysisValue) Type(ctx context.Context) attr.Type {
	return AdvancedAnalysisType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AdvancedAnalysisValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"forecast":      basetypes.BoolType{},
		"not_trending":  basetypes.BoolType{},
		"trending_down": basetypes.BoolType{},
		"trending_up":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CustomTimeRangeType{}

type CustomTimeRangeType struct {
	basetypes.ObjectType
}

func (t CustomTimeRangeType) Equal(o attr.Type) bool {
	other, ok := o.(CustomTimeRangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomTimeRangeType) String() string {
	return "CustomTimeRangeType"
}

func (t CustomTimeRangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fromAttribute, ok := attributes["from"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from is missing from object`)

		return nil, diags
	}

	fromVal, ok := fromAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from expected to be basetypes.StringValue, was: %T`, fromAttribute))
	}

	toAttribute, ok := attributes["to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to is missing from object`)

		return nil, diags
	}

	toVal, ok := toAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to expected to be basetypes.StringValue, was: %T`, toAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomTimeRangeValue{
		From:  fromVal,
		To:    toVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCustomTimeRangeValueNull() CustomTimeRangeValue {
	return CustomTimeRangeValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomTimeRangeValueUnknown() CustomTimeRangeValue {
	return CustomTimeRangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomTimeRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomTimeRangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomTimeRangeValue Attribute Value",
				"While creating a CustomTimeRangeValue value, a missing attribute value was detected. "+
					"A CustomTimeRangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomTimeRangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomTimeRangeValue Attribute Type",
				"While creating a CustomTimeRangeValue value, an invalid attribute value was detected. "+
					"A CustomTimeRangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomTimeRangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomTimeRangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomTimeRangeValue Attribute Value",
				"While creating a CustomTimeRangeValue value, an extra attribute value was detected. "+
					"A CustomTimeRangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomTimeRangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomTimeRangeValueUnknown(), diags
	}

	fromAttribute, ok := attributes["from"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from is missing from object`)

		return NewCustomTimeRangeValueUnknown(), diags
	}

	fromVal, ok := fromAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from expected to be basetypes.StringValue, was: %T`, fromAttribute))
	}

	toAttribute, ok := attributes["to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to is missing from object`)

		return NewCustomTimeRangeValueUnknown(), diags
	}

	toVal, ok := toAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to expected to be basetypes.StringValue, was: %T`, toAttribute))
	}

	if diags.HasError() {
		return NewCustomTimeRangeValueUnknown(), diags
	}

	return CustomTimeRangeValue{
		From:  fromVal,
		To:    toVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCustomTimeRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomTimeRangeValue {
	object, diags := NewCustomTimeRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomTimeRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomTimeRangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomTimeRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomTimeRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomTimeRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomTimeRangeValueMust(CustomTimeRangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomTimeRangeType) ValueType(ctx context.Context) attr.Value {
	return CustomTimeRangeValue{}
}

var _ basetypes.ObjectValuable = CustomTimeRangeValue{}

type CustomTimeRangeValue struct {
	From  basetypes.StringValue `tfsdk:"from"`
	To    basetypes.StringValue `tfsdk:"to"`
	state attr.ValueState
}

func (v CustomTimeRangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["from"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.From.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from"] = val

		val, err = v.To.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomTimeRangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomTimeRangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomTimeRangeValue) String() string {
	return "CustomTimeRangeValue"
}

func (v CustomTimeRangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"from": basetypes.StringType{},
		"to":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"from": v.From,
			"to":   v.To,
		})

	return objVal, diags
}

func (v CustomTimeRangeValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomTimeRangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.From.Equal(other.From) {
		return false
	}

	if !v.To.Equal(other.To) {
		return false
	}

	return true
}

func (v CustomTimeRangeValue) Type(ctx context.Context) attr.Type {
	return CustomTimeRangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomTimeRangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"from": basetypes.StringType{},
		"to":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DimensionsType{}

type DimensionsType struct {
	basetypes.ObjectType
}

func (t DimensionsType) Equal(o attr.Type) bool {
	other, ok := o.(DimensionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DimensionsType) String() string {
	return "DimensionsType"
}

func (t DimensionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DimensionsValue{
		Id:             idVal,
		DimensionsType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewDimensionsValueNull() DimensionsValue {
	return DimensionsValue{
		state: attr.ValueStateNull,
	}
}

func NewDimensionsValueUnknown() DimensionsValue {
	return DimensionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDimensionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DimensionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DimensionsValue Attribute Value",
				"While creating a DimensionsValue value, a missing attribute value was detected. "+
					"A DimensionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DimensionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DimensionsValue Attribute Type",
				"While creating a DimensionsValue value, an invalid attribute value was detected. "+
					"A DimensionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DimensionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DimensionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DimensionsValue Attribute Value",
				"While creating a DimensionsValue value, an extra attribute value was detected. "+
					"A DimensionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DimensionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDimensionsValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDimensionsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDimensionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDimensionsValueUnknown(), diags
	}

	return DimensionsValue{
		Id:             idVal,
		DimensionsType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewDimensionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DimensionsValue {
	object, diags := NewDimensionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDimensionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DimensionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDimensionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDimensionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDimensionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDimensionsValueMust(DimensionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DimensionsType) ValueType(ctx context.Context) attr.Value {
	return DimensionsValue{}
}

var _ basetypes.ObjectValuable = DimensionsValue{}

type DimensionsValue struct {
	Id             basetypes.StringValue `tfsdk:"id"`
	DimensionsType basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v DimensionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DimensionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DimensionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DimensionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DimensionsValue) String() string {
	return "DimensionsValue"
}

func (v DimensionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DimensionsType,
		})

	return objVal, diags
}

func (v DimensionsValue) Equal(o attr.Value) bool {
	other, ok := o.(DimensionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DimensionsType.Equal(other.DimensionsType) {
		return false
	}

	return true
}

func (v DimensionsValue) Type(ctx context.Context) attr.Type {
	return DimensionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DimensionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	inverseAttribute, ok := attributes["inverse"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inverse is missing from object`)

		return nil, diags
	}

	inverseVal, ok := inverseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inverse expected to be basetypes.BoolValue, was: %T`, inverseAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		Id:          idVal,
		Inverse:     inverseVal,
		Mode:        modeVal,
		FiltersType: typeVal,
		Values:      valuesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	inverseAttribute, ok := attributes["inverse"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inverse is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	inverseVal, ok := inverseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inverse expected to be basetypes.BoolValue, was: %T`, inverseAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		Id:          idVal,
		Inverse:     inverseVal,
		Mode:        modeVal,
		FiltersType: typeVal,
		Values:      valuesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	Id          basetypes.StringValue `tfsdk:"id"`
	Inverse     basetypes.BoolValue   `tfsdk:"inverse"`
	Mode        basetypes.StringValue `tfsdk:"mode"`
	FiltersType basetypes.StringValue `tfsdk:"type"`
	Values      basetypes.ListValue   `tfsdk:"values"`
	state       attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inverse"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Inverse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inverse"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.FiltersType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valuesVal basetypes.ListValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.ListUnknown(types.StringType)
	case v.Values.IsNull():
		valuesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.ListValue(types.StringType, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"id":      basetypes.StringType{},
			"inverse": basetypes.BoolType{},
			"mode":    basetypes.StringType{},
			"type":    basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"id":      basetypes.StringType{},
		"inverse": basetypes.BoolType{},
		"mode":    basetypes.StringType{},
		"type":    basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":      v.Id,
			"inverse": v.Inverse,
			"mode":    v.Mode,
			"type":    v.FiltersType,
			"values":  valuesVal,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Inverse.Equal(other.Inverse) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.FiltersType.Equal(other.FiltersType) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":      basetypes.StringType{},
		"inverse": basetypes.BoolType{},
		"mode":    basetypes.StringType{},
		"type":    basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = GroupType{}

type GroupType struct {
	basetypes.ObjectType
}

func (t GroupType) Equal(o attr.Type) bool {
	other, ok := o.(GroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GroupType) String() string {
	return "GroupType"
}

func (t GroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return nil, diags
	}

	limitVal, ok := limitAttribute.(LimitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be LimitValue, was: %T`, limitAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GroupValue{
		Id:        idVal,
		Limit:     limitVal,
		GroupType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewGroupValueNull() GroupValue {
	return GroupValue{
		state: attr.ValueStateNull,
	}
}

func NewGroupValueUnknown() GroupValue {
	return GroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GroupValue Attribute Value",
				"While creating a GroupValue value, a missing attribute value was detected. "+
					"A GroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GroupValue Attribute Type",
				"While creating a GroupValue value, an invalid attribute value was detected. "+
					"A GroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GroupValue Attribute Value",
				"While creating a GroupValue value, an extra attribute value was detected. "+
					"A GroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGroupValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewGroupValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return NewGroupValueUnknown(), diags
	}

	limitVal, ok := limitAttribute.(LimitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be LimitValue, was: %T`, limitAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewGroupValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewGroupValueUnknown(), diags
	}

	return GroupValue{
		Id:        idVal,
		Limit:     limitVal,
		GroupType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GroupValue {
	object, diags := NewGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGroupValueMust(GroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GroupType) ValueType(ctx context.Context) attr.Value {
	return GroupValue{}
}

var _ basetypes.ObjectValuable = GroupValue{}

type GroupValue struct {
	Id        basetypes.StringValue `tfsdk:"id"`
	Limit     LimitValue            `tfsdk:"limit"`
	GroupType basetypes.StringValue `tfsdk:"type"`
	state     attr.ValueState
}

func (v GroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limit"] = LimitType{
		basetypes.ObjectType{
			AttrTypes: LimitValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Limit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit"] = val

		val, err = v.GroupType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GroupValue) String() string {
	return "GroupValue"
}

func (v GroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var limit attr.Value

	{
		limit = v.Limit
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"limit": LimitType{
			basetypes.ObjectType{
				AttrTypes: LimitValue{}.AttributeTypes(ctx),
			},
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":    v.Id,
			"limit": limit,
			"type":  v.GroupType,
		})

	return objVal, diags
}

func (v GroupValue) Equal(o attr.Value) bool {
	other, ok := o.(GroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Limit.Equal(other.Limit) {
		return false
	}

	if !v.GroupType.Equal(other.GroupType) {
		return false
	}

	return true
}

func (v GroupValue) Type(ctx context.Context) attr.Type {
	return GroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"limit": LimitType{
			basetypes.ObjectType{
				AttrTypes: LimitValue{}.AttributeTypes(ctx),
			},
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LimitType{}

type LimitType struct {
	basetypes.ObjectType
}

func (t LimitType) Equal(o attr.Type) bool {
	other, ok := o.(LimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LimitType) String() string {
	return "LimitType"
}

func (t LimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(MetricValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be MetricValue, was: %T`, metricAttribute))
	}

	sortAttribute, ok := attributes["sort"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sort is missing from object`)

		return nil, diags
	}

	sortVal, ok := sortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sort expected to be basetypes.StringValue, was: %T`, sortAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LimitValue{
		Metric: metricVal,
		Sort:   sortVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewLimitValueNull() LimitValue {
	return LimitValue{
		state: attr.ValueStateNull,
	}
}

func NewLimitValueUnknown() LimitValue {
	return LimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LimitValue Attribute Value",
				"While creating a LimitValue value, a missing attribute value was detected. "+
					"A LimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LimitValue Attribute Type",
				"While creating a LimitValue value, an invalid attribute value was detected. "+
					"A LimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LimitValue Attribute Value",
				"While creating a LimitValue value, an extra attribute value was detected. "+
					"A LimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLimitValueUnknown(), diags
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewLimitValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(MetricValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be MetricValue, was: %T`, metricAttribute))
	}

	sortAttribute, ok := attributes["sort"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sort is missing from object`)

		return NewLimitValueUnknown(), diags
	}

	sortVal, ok := sortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sort expected to be basetypes.StringValue, was: %T`, sortAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewLimitValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewLimitValueUnknown(), diags
	}

	return LimitValue{
		Metric: metricVal,
		Sort:   sortVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LimitValue {
	object, diags := NewLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLimitValueMust(LimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LimitType) ValueType(ctx context.Context) attr.Value {
	return LimitValue{}
}

var _ basetypes.ObjectValuable = LimitValue{}

type LimitValue struct {
	Metric MetricValue           `tfsdk:"metric"`
	Sort   basetypes.StringValue `tfsdk:"sort"`
	Value  basetypes.Int64Value  `tfsdk:"value"`
	state  attr.ValueState
}

func (v LimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["metric"] = MetricType{
		basetypes.ObjectType{
			AttrTypes: MetricValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["sort"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Sort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sort"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LimitValue) String() string {
	return "LimitValue"
}

func (v LimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metric attr.Value

	{
		metric = v.Metric
	}

	attributeTypes := map[string]attr.Type{
		"metric": MetricType{
			basetypes.ObjectType{
				AttrTypes: MetricValue{}.AttributeTypes(ctx),
			},
		},
		"sort":  basetypes.StringType{},
		"value": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"metric": metric,
			"sort":   v.Sort,
			"value":  v.Value,
		})

	return objVal, diags
}

func (v LimitValue) Equal(o attr.Value) bool {
	other, ok := o.(LimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Sort.Equal(other.Sort) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v LimitValue) Type(ctx context.Context) attr.Type {
	return LimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"metric": MetricType{
			basetypes.ObjectType{
				AttrTypes: MetricValue{}.AttributeTypes(ctx),
			},
		},
		"sort":  basetypes.StringType{},
		"value": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetricType{}

type MetricType struct {
	basetypes.ObjectType
}

func (t MetricType) Equal(o attr.Type) bool {
	other, ok := o.(MetricType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetricType) String() string {
	return "MetricType"
}

func (t MetricType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetricValue{
		MetricType: typeVal,
		Value:      valueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMetricValueNull() MetricValue {
	return MetricValue{
		state: attr.ValueStateNull,
	}
}

func NewMetricValueUnknown() MetricValue {
	return MetricValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetricValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetricValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetricValue Attribute Value",
				"While creating a MetricValue value, a missing attribute value was detected. "+
					"A MetricValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetricValue Attribute Type",
				"While creating a MetricValue value, an invalid attribute value was detected. "+
					"A MetricValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetricValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetricValue Attribute Value",
				"While creating a MetricValue value, an extra attribute value was detected. "+
					"A MetricValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetricValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetricValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewMetricValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewMetricValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewMetricValueUnknown(), diags
	}

	return MetricValue{
		MetricType: typeVal,
		Value:      valueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMetricValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetricValue {
	object, diags := NewMetricValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetricValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetricType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetricValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetricValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetricValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetricValueMust(MetricValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetricType) ValueType(ctx context.Context) attr.Value {
	return MetricValue{}
}

var _ basetypes.ObjectValuable = MetricValue{}

type MetricValue struct {
	MetricType basetypes.StringValue `tfsdk:"type"`
	Value      basetypes.StringValue `tfsdk:"value"`
	state      attr.ValueState
}

func (v MetricValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MetricType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetricValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetricValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetricValue) String() string {
	return "MetricValue"
}

func (v MetricValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.MetricType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v MetricValue) Equal(o attr.Value) bool {
	other, ok := o.(MetricValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MetricType.Equal(other.MetricType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v MetricValue) Type(ctx context.Context) attr.Type {
	return MetricType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetricValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetricFilterType{}

type MetricFilterType struct {
	basetypes.ObjectType
}

func (t MetricFilterType) Equal(o attr.Type) bool {
	other, ok := o.(MetricFilterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetricFilterType) String() string {
	return "MetricFilterType"
}

func (t MetricFilterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(MetricValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be MetricValue, was: %T`, metricAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetricFilterValue{
		Metric:   metricVal,
		Operator: operatorVal,
		Values:   valuesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMetricFilterValueNull() MetricFilterValue {
	return MetricFilterValue{
		state: attr.ValueStateNull,
	}
}

func NewMetricFilterValueUnknown() MetricFilterValue {
	return MetricFilterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetricFilterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetricFilterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetricFilterValue Attribute Value",
				"While creating a MetricFilterValue value, a missing attribute value was detected. "+
					"A MetricFilterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricFilterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetricFilterValue Attribute Type",
				"While creating a MetricFilterValue value, an invalid attribute value was detected. "+
					"A MetricFilterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricFilterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetricFilterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetricFilterValue Attribute Value",
				"While creating a MetricFilterValue value, an extra attribute value was detected. "+
					"A MetricFilterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetricFilterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetricFilterValueUnknown(), diags
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewMetricFilterValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(MetricValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be MetricValue, was: %T`, metricAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewMetricFilterValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewMetricFilterValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewMetricFilterValueUnknown(), diags
	}

	return MetricFilterValue{
		Metric:   metricVal,
		Operator: operatorVal,
		Values:   valuesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMetricFilterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetricFilterValue {
	object, diags := NewMetricFilterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetricFilterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetricFilterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetricFilterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetricFilterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetricFilterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetricFilterValueMust(MetricFilterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetricFilterType) ValueType(ctx context.Context) attr.Value {
	return MetricFilterValue{}
}

var _ basetypes.ObjectValuable = MetricFilterValue{}

type MetricFilterValue struct {
	Metric   MetricValue           `tfsdk:"metric"`
	Operator basetypes.StringValue `tfsdk:"operator"`
	Values   basetypes.ListValue   `tfsdk:"values"`
	state    attr.ValueState
}

func (v MetricFilterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["metric"] = MetricType{
		basetypes.ObjectType{
			AttrTypes: MetricValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetricFilterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetricFilterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetricFilterValue) String() string {
	return "MetricFilterValue"
}

func (v MetricFilterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metric attr.Value

	{
		metric = v.Metric
	}

	var valuesVal basetypes.ListValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.ListUnknown(types.Float64Type)
	case v.Values.IsNull():
		valuesVal = types.ListNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.ListValue(types.Float64Type, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"metric": MetricType{
				basetypes.ObjectType{
					AttrTypes: MetricValue{}.AttributeTypes(ctx),
				},
			},
			"operator": basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.Float64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"metric": MetricType{
			basetypes.ObjectType{
				AttrTypes: MetricValue{}.AttributeTypes(ctx),
			},
		},
		"operator": basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.Float64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"metric":   metric,
			"operator": v.Operator,
			"values":   valuesVal,
		})

	return objVal, diags
}

func (v MetricFilterValue) Equal(o attr.Value) bool {
	other, ok := o.(MetricFilterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v MetricFilterValue) Type(ctx context.Context) attr.Type {
	return MetricFilterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetricFilterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"metric": MetricType{
			basetypes.ObjectType{
				AttrTypes: MetricValue{}.AttributeTypes(ctx),
			},
		},
		"operator": basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.Float64Type,
		},
	}
}

var _ basetypes.ObjectTypable = SplitsType{}

type SplitsType struct {
	basetypes.ObjectType
}

func (t SplitsType) Equal(o attr.Type) bool {
	other, ok := o.(SplitsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SplitsType) String() string {
	return "SplitsType"
}

func (t SplitsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	includeOriginAttribute, ok := attributes["include_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_origin is missing from object`)

		return nil, diags
	}

	includeOriginVal, ok := includeOriginAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_origin expected to be basetypes.BoolValue, was: %T`, includeOriginAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	originAttribute, ok := attributes["origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin is missing from object`)

		return nil, diags
	}

	originVal, ok := originAttribute.(OriginValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin expected to be OriginValue, was: %T`, originAttribute))
	}

	targetsAttribute, ok := attributes["targets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`targets is missing from object`)

		return nil, diags
	}

	targetsVal, ok := targetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`targets expected to be basetypes.ListValue, was: %T`, targetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SplitsValue{
		Id:            idVal,
		IncludeOrigin: includeOriginVal,
		Mode:          modeVal,
		Origin:        originVal,
		Targets:       targetsVal,
		SplitsType:    typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSplitsValueNull() SplitsValue {
	return SplitsValue{
		state: attr.ValueStateNull,
	}
}

func NewSplitsValueUnknown() SplitsValue {
	return SplitsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSplitsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SplitsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SplitsValue Attribute Value",
				"While creating a SplitsValue value, a missing attribute value was detected. "+
					"A SplitsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SplitsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SplitsValue Attribute Type",
				"While creating a SplitsValue value, an invalid attribute value was detected. "+
					"A SplitsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SplitsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SplitsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SplitsValue Attribute Value",
				"While creating a SplitsValue value, an extra attribute value was detected. "+
					"A SplitsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SplitsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSplitsValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSplitsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	includeOriginAttribute, ok := attributes["include_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_origin is missing from object`)

		return NewSplitsValueUnknown(), diags
	}

	includeOriginVal, ok := includeOriginAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_origin expected to be basetypes.BoolValue, was: %T`, includeOriginAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewSplitsValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	originAttribute, ok := attributes["origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin is missing from object`)

		return NewSplitsValueUnknown(), diags
	}

	originVal, ok := originAttribute.(OriginValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin expected to be OriginValue, was: %T`, originAttribute))
	}

	targetsAttribute, ok := attributes["targets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`targets is missing from object`)

		return NewSplitsValueUnknown(), diags
	}

	targetsVal, ok := targetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`targets expected to be basetypes.ListValue, was: %T`, targetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSplitsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSplitsValueUnknown(), diags
	}

	return SplitsValue{
		Id:            idVal,
		IncludeOrigin: includeOriginVal,
		Mode:          modeVal,
		Origin:        originVal,
		Targets:       targetsVal,
		SplitsType:    typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSplitsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SplitsValue {
	object, diags := NewSplitsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSplitsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SplitsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSplitsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSplitsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSplitsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSplitsValueMust(SplitsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SplitsType) ValueType(ctx context.Context) attr.Value {
	return SplitsValue{}
}

var _ basetypes.ObjectValuable = SplitsValue{}

type SplitsValue struct {
	Id            basetypes.StringValue `tfsdk:"id"`
	IncludeOrigin basetypes.BoolValue   `tfsdk:"include_origin"`
	Mode          basetypes.StringValue `tfsdk:"mode"`
	Origin        OriginValue           `tfsdk:"origin"`
	Targets       basetypes.ListValue   `tfsdk:"targets"`
	SplitsType    basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v SplitsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["include_origin"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["origin"] = OriginType{
		basetypes.ObjectType{
			AttrTypes: OriginValue{}.AttributeTypes(ctx),
		},
	}.TerraformType(ctx)
	attrTypes["targets"] = basetypes.ListType{
		ElemType: TargetsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IncludeOrigin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_origin"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Origin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["origin"] = val

		val, err = v.Targets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["targets"] = val

		val, err = v.SplitsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SplitsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SplitsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SplitsValue) String() string {
	return "SplitsValue"
}

func (v SplitsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var origin attr.Value

	{
		origin = v.Origin
	}

	var targets attr.Value

	{
		targets = v.Targets
	}

	attributeTypes := map[string]attr.Type{
		"id":             basetypes.StringType{},
		"include_origin": basetypes.BoolType{},
		"mode":           basetypes.StringType{},
		"origin": OriginType{
			basetypes.ObjectType{
				AttrTypes: OriginValue{}.AttributeTypes(ctx),
			},
		},
		"targets": basetypes.ListType{
			ElemType: TargetsValue{}.Type(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":             v.Id,
			"include_origin": v.IncludeOrigin,
			"mode":           v.Mode,
			"origin":         origin,
			"targets":        targets,
			"type":           v.SplitsType,
		})

	return objVal, diags
}

func (v SplitsValue) Equal(o attr.Value) bool {
	other, ok := o.(SplitsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IncludeOrigin.Equal(other.IncludeOrigin) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Origin.Equal(other.Origin) {
		return false
	}

	if !v.Targets.Equal(other.Targets) {
		return false
	}

	if !v.SplitsType.Equal(other.SplitsType) {
		return false
	}

	return true
}

func (v SplitsValue) Type(ctx context.Context) attr.Type {
	return SplitsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SplitsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":             basetypes.StringType{},
		"include_origin": basetypes.BoolType{},
		"mode":           basetypes.StringType{},
		"origin": OriginType{
			basetypes.ObjectType{
				AttrTypes: OriginValue{}.AttributeTypes(ctx),
			},
		},
		"targets": basetypes.ListType{
			ElemType: TargetsValue{}.Type(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OriginType{}

type OriginType struct {
	basetypes.ObjectType
}

func (t OriginType) Equal(o attr.Type) bool {
	other, ok := o.(OriginType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OriginType) String() string {
	return "OriginType"
}

func (t OriginType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OriginValue{
		Id:         idVal,
		OriginType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOriginValueNull() OriginValue {
	return OriginValue{
		state: attr.ValueStateNull,
	}
}

func NewOriginValueUnknown() OriginValue {
	return OriginValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOriginValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OriginValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OriginValue Attribute Value",
				"While creating a OriginValue value, a missing attribute value was detected. "+
					"A OriginValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OriginValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OriginValue Attribute Type",
				"While creating a OriginValue value, an invalid attribute value was detected. "+
					"A OriginValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OriginValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OriginValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OriginValue Attribute Value",
				"While creating a OriginValue value, an extra attribute value was detected. "+
					"A OriginValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OriginValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOriginValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewOriginValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOriginValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOriginValueUnknown(), diags
	}

	return OriginValue{
		Id:         idVal,
		OriginType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOriginValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OriginValue {
	object, diags := NewOriginValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOriginValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OriginType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOriginValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOriginValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOriginValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOriginValueMust(OriginValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OriginType) ValueType(ctx context.Context) attr.Value {
	return OriginValue{}
}

var _ basetypes.ObjectValuable = OriginValue{}

type OriginValue struct {
	Id         basetypes.StringValue `tfsdk:"id"`
	OriginType basetypes.StringValue `tfsdk:"type"`
	state      attr.ValueState
}

func (v OriginValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.OriginType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OriginValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OriginValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OriginValue) String() string {
	return "OriginValue"
}

func (v OriginValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.OriginType,
		})

	return objVal, diags
}

func (v OriginValue) Equal(o attr.Value) bool {
	other, ok := o.(OriginValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.OriginType.Equal(other.OriginType) {
		return false
	}

	return true
}

func (v OriginValue) Type(ctx context.Context) attr.Type {
	return OriginType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OriginValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TargetsType{}

type TargetsType struct {
	basetypes.ObjectType
}

func (t TargetsType) Equal(o attr.Type) bool {
	other, ok := o.(TargetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetsType) String() string {
	return "TargetsType"
}

func (t TargetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Float64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetsValue{
		Id:          idVal,
		TargetsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetsValueNull() TargetsValue {
	return TargetsValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetsValueUnknown() TargetsValue {
	return TargetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetsValue Attribute Value",
				"While creating a TargetsValue value, a missing attribute value was detected. "+
					"A TargetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetsValue Attribute Type",
				"While creating a TargetsValue value, an invalid attribute value was detected. "+
					"A TargetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetsValue Attribute Value",
				"While creating a TargetsValue value, an extra attribute value was detected. "+
					"A TargetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetsValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewTargetsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewTargetsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTargetsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Float64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTargetsValueUnknown(), diags
	}

	return TargetsValue{
		Id:          idVal,
		TargetsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTargetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetsValue {
	object, diags := NewTargetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetsValueMust(TargetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetsType) ValueType(ctx context.Context) attr.Value {
	return TargetsValue{}
}

var _ basetypes.ObjectValuable = TargetsValue{}

type TargetsValue struct {
	Id          basetypes.StringValue  `tfsdk:"id"`
	TargetsType basetypes.StringValue  `tfsdk:"type"`
	Value       basetypes.Float64Value `tfsdk:"value"`
	state       attr.ValueState
}

func (v TargetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.TargetsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetsValue) String() string {
	return "TargetsValue"
}

func (v TargetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":    basetypes.StringType{},
		"type":  basetypes.StringType{},
		"value": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":    v.Id,
			"type":  v.TargetsType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TargetsValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.TargetsType.Equal(other.TargetsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TargetsValue) Type(ctx context.Context) attr.Type {
	return TargetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":    basetypes.StringType{},
		"type":  basetypes.StringType{},
		"value": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = TimeRangeType{}

type TimeRangeType struct {
	basetypes.ObjectType
}

func (t TimeRangeType) Equal(o attr.Type) bool {
	other, ok := o.(TimeRangeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimeRangeType) String() string {
	return "TimeRangeType"
}

func (t TimeRangeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return nil, diags
	}

	amountVal, ok := amountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.Int64Value, was: %T`, amountAttribute))
	}

	includeCurrentAttribute, ok := attributes["include_current"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_current is missing from object`)

		return nil, diags
	}

	includeCurrentVal, ok := includeCurrentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_current expected to be basetypes.BoolValue, was: %T`, includeCurrentAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be basetypes.StringValue, was: %T`, unitAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimeRangeValue{
		Amount:         amountVal,
		IncludeCurrent: includeCurrentVal,
		Mode:           modeVal,
		Unit:           unitVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTimeRangeValueNull() TimeRangeValue {
	return TimeRangeValue{
		state: attr.ValueStateNull,
	}
}

func NewTimeRangeValueUnknown() TimeRangeValue {
	return TimeRangeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimeRangeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimeRangeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimeRangeValue Attribute Value",
				"While creating a TimeRangeValue value, a missing attribute value was detected. "+
					"A TimeRangeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeRangeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimeRangeValue Attribute Type",
				"While creating a TimeRangeValue value, an invalid attribute value was detected. "+
					"A TimeRangeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeRangeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimeRangeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimeRangeValue Attribute Value",
				"While creating a TimeRangeValue value, an extra attribute value was detected. "+
					"A TimeRangeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimeRangeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimeRangeValueUnknown(), diags
	}

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return NewTimeRangeValueUnknown(), diags
	}

	amountVal, ok := amountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.Int64Value, was: %T`, amountAttribute))
	}

	includeCurrentAttribute, ok := attributes["include_current"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_current is missing from object`)

		return NewTimeRangeValueUnknown(), diags
	}

	includeCurrentVal, ok := includeCurrentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_current expected to be basetypes.BoolValue, was: %T`, includeCurrentAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewTimeRangeValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewTimeRangeValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be basetypes.StringValue, was: %T`, unitAttribute))
	}

	if diags.HasError() {
		return NewTimeRangeValueUnknown(), diags
	}

	return TimeRangeValue{
		Amount:         amountVal,
		IncludeCurrent: includeCurrentVal,
		Mode:           modeVal,
		Unit:           unitVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTimeRangeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimeRangeValue {
	object, diags := NewTimeRangeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimeRangeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimeRangeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimeRangeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimeRangeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimeRangeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimeRangeValueMust(TimeRangeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimeRangeType) ValueType(ctx context.Context) attr.Value {
	return TimeRangeValue{}
}

var _ basetypes.ObjectValuable = TimeRangeValue{}

type TimeRangeValue struct {
	Amount         basetypes.Int64Value  `tfsdk:"amount"`
	IncludeCurrent basetypes.BoolValue   `tfsdk:"include_current"`
	Mode           basetypes.StringValue `tfsdk:"mode"`
	Unit           basetypes.StringValue `tfsdk:"unit"`
	state          attr.ValueState
}

func (v TimeRangeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["amount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["include_current"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Amount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount"] = val

		val, err = v.IncludeCurrent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_current"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimeRangeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimeRangeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimeRangeValue) String() string {
	return "TimeRangeValue"
}

func (v TimeRangeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"amount":          basetypes.Int64Type{},
		"include_current": basetypes.BoolType{},
		"mode":            basetypes.StringType{},
		"unit":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount":          v.Amount,
			"include_current": v.IncludeCurrent,
			"mode":            v.Mode,
			"unit":            v.Unit,
		})

	return objVal, diags
}

func (v TimeRangeValue) Equal(o attr.Value) bool {
	other, ok := o.(TimeRangeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Amount.Equal(other.Amount) {
		return false
	}

	if !v.IncludeCurrent.Equal(other.IncludeCurrent) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	return true
}

func (v TimeRangeValue) Type(ctx context.Context) attr.Type {
	return TimeRangeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimeRangeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount":          basetypes.Int64Type{},
		"include_current": basetypes.BoolType{},
		"mode":            basetypes.StringType{},
		"unit":            basetypes.StringType{},
	}
}
