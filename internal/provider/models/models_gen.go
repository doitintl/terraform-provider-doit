// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package models

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_keyScopes         = "api_key.Scopes"
	CustomerContextScopes = "customerContext.Scopes"
)

// Defines values for AlertConfigTimeInterval.
const (
	AlertConfigTimeIntervalDay     AlertConfigTimeInterval = "day"
	AlertConfigTimeIntervalHour    AlertConfigTimeInterval = "hour"
	AlertConfigTimeIntervalMonth   AlertConfigTimeInterval = "month"
	AlertConfigTimeIntervalQuarter AlertConfigTimeInterval = "quarter"
	AlertConfigTimeIntervalWeek    AlertConfigTimeInterval = "week"
	AlertConfigTimeIntervalYear    AlertConfigTimeInterval = "year"
)

// Defines values for AllocationAllocationType.
const (
	AllocationAllocationTypeGroup  AllocationAllocationType = "group"
	AllocationAllocationTypeSingle AllocationAllocationType = "single"
)

// Defines values for AllocationComponentMode.
const (
	AllocationComponentModeContains   AllocationComponentMode = "contains"
	AllocationComponentModeEndsWith   AllocationComponentMode = "ends_with"
	AllocationComponentModeIs         AllocationComponentMode = "is"
	AllocationComponentModeRegexp     AllocationComponentMode = "regexp"
	AllocationComponentModeStartsWith AllocationComponentMode = "starts_with"
)

// Defines values for AllocationDeleteValidationType.
const (
	AllocationDeleteValidationTypeGroup  AllocationDeleteValidationType = "group"
	AllocationDeleteValidationTypeSingle AllocationDeleteValidationType = "single"
)

// Defines values for AllocationListItemAllocationType.
const (
	AllocationListItemAllocationTypeGroup  AllocationListItemAllocationType = "group"
	AllocationListItemAllocationTypeSingle AllocationListItemAllocationType = "single"
)

// Defines values for AnomalyItemStatus.
const (
	AnomalyItemStatusActive   AnomalyItemStatus = "active"
	AnomalyItemStatusInactive AnomalyItemStatus = "inactive"
)

// Defines values for AttributionGroupListItemType.
const (
	AttributionGroupListItemTypeCustom  AttributionGroupListItemType = "custom"
	AttributionGroupListItemTypeManaged AttributionGroupListItemType = "managed"
	AttributionGroupListItemTypePreset  AttributionGroupListItemType = "preset"
)

// Defines values for BudgetAPIPublic.
const (
	BudgetAPIPublicEditor BudgetAPIPublic = "editor"
	BudgetAPIPublicOwner  BudgetAPIPublic = "owner"
	BudgetAPIPublicViewer BudgetAPIPublic = "viewer"
)

// Defines values for BudgetCreateUpdateRequestMetric.
const (
	AmortizedCost BudgetCreateUpdateRequestMetric = "amortized_cost"
	Cost          BudgetCreateUpdateRequestMetric = "cost"
)

// Defines values for BudgetCreateUpdateRequestPublic.
const (
	BudgetCreateUpdateRequestPublicEditor BudgetCreateUpdateRequestPublic = "editor"
	BudgetCreateUpdateRequestPublicOwner  BudgetCreateUpdateRequestPublic = "owner"
	BudgetCreateUpdateRequestPublicViewer BudgetCreateUpdateRequestPublic = "viewer"
)

// Defines values for CloudIncidentListItemPlatform.
const (
	CloudIncidentListItemPlatformAmazonWebServices CloudIncidentListItemPlatform = "amazon-web-services"
	CloudIncidentListItemPlatformGoogleCloud       CloudIncidentListItemPlatform = "google-cloud"
	CloudIncidentListItemPlatformMicrosoftAzure    CloudIncidentListItemPlatform = "microsoft-azure"
)

// Defines values for CloudIncidentListItemStatus.
const (
	CloudIncidentListItemStatusActive   CloudIncidentListItemStatus = "active"
	CloudIncidentListItemStatusArchived CloudIncidentListItemStatus = "archived"
)

// Defines values for CollaboratorRole.
const (
	CollaboratorRoleEditor CollaboratorRole = "editor"
	CollaboratorRoleOwner  CollaboratorRole = "owner"
	CollaboratorRoleViewer CollaboratorRole = "viewer"
)

// Defines values for CommitmentExternalProvider.
const (
	CommitmentExternalProviderAmazonWebServices CommitmentExternalProvider = "amazon-web-services"
	CommitmentExternalProviderGoogleCloud       CommitmentExternalProvider = "google-cloud"
	CommitmentExternalProviderMicrosoftAzure    CommitmentExternalProvider = "microsoft-azure"
)

// Defines values for CommitmentExternalListItemProvider.
const (
	CommitmentExternalListItemProviderAmazonWebServices CommitmentExternalListItemProvider = "amazon-web-services"
	CommitmentExternalListItemProviderGoogleCloud       CommitmentExternalListItemProvider = "google-cloud"
	CommitmentExternalListItemProviderMicrosoftAzure    CommitmentExternalListItemProvider = "microsoft-azure"
)

// Defines values for CreateLabelRequestColor.
const (
	CreateLabelRequestColorApricot    CreateLabelRequestColor = "apricot"
	CreateLabelRequestColorBlue       CreateLabelRequestColor = "blue"
	CreateLabelRequestColorLavender   CreateLabelRequestColor = "lavender"
	CreateLabelRequestColorLime       CreateLabelRequestColor = "lime"
	CreateLabelRequestColorMint       CreateLabelRequestColor = "mint"
	CreateLabelRequestColorPurple     CreateLabelRequestColor = "purple"
	CreateLabelRequestColorRosePink   CreateLabelRequestColor = "rosePink"
	CreateLabelRequestColorSkyBlue    CreateLabelRequestColor = "skyBlue"
	CreateLabelRequestColorSlateGrey  CreateLabelRequestColor = "slateGrey"
	CreateLabelRequestColorSoftYellow CreateLabelRequestColor = "softYellow"
	CreateLabelRequestColorTeal       CreateLabelRequestColor = "teal"
)

// Defines values for Currency.
const (
	AED Currency = "AED"
	AUD Currency = "AUD"
	BRL Currency = "BRL"
	CAD Currency = "CAD"
	CHF Currency = "CHF"
	COP Currency = "COP"
	DKK Currency = "DKK"
	EGP Currency = "EGP"
	EUR Currency = "EUR"
	GBP Currency = "GBP"
	IDR Currency = "IDR"
	ILS Currency = "ILS"
	JPY Currency = "JPY"
	MXN Currency = "MXN"
	MYR Currency = "MYR"
	NOK Currency = "NOK"
	SEK Currency = "SEK"
	SGD Currency = "SGD"
	THB Currency = "THB"
	TWD Currency = "TWD"
	USD Currency = "USD"
	ZAR Currency = "ZAR"
)

// Defines values for DimensionsTypes.
const (
	DimensionsTypesAttribution      DimensionsTypes = "attribution"
	DimensionsTypesAttributionGroup DimensionsTypes = "attribution_group"
	DimensionsTypesDatetime         DimensionsTypes = "datetime"
	DimensionsTypesFixed            DimensionsTypes = "fixed"
	DimensionsTypesGke              DimensionsTypes = "gke"
	DimensionsTypesGkeLabel         DimensionsTypes = "gke_label"
	DimensionsTypesLabel            DimensionsTypes = "label"
	DimensionsTypesOptional         DimensionsTypes = "optional"
	DimensionsTypesProjectLabel     DimensionsTypes = "project_label"
	DimensionsTypesSystemLabel      DimensionsTypes = "system_label"
	DimensionsTypesTag              DimensionsTypes = "tag"
)

// Defines values for ExternalConfigAggregation.
const (
	PercentCol   ExternalConfigAggregation = "percent_col"
	PercentRow   ExternalConfigAggregation = "percent_row"
	PercentTotal ExternalConfigAggregation = "percent_total"
	Total        ExternalConfigAggregation = "total"
)

// Defines values for ExternalConfigDataSource.
const (
	Billing               ExternalConfigDataSource = "billing"
	BillingDatahub        ExternalConfigDataSource = "billing-datahub"
	Bqlens                ExternalConfigDataSource = "bqlens"
	KubernetesUtilization ExternalConfigDataSource = "kubernetes-utilization"
)

// Defines values for ExternalConfigDisplayValues.
const (
	AbsoluteAndPercentage ExternalConfigDisplayValues = "absolute_and_percentage"
	AbsoluteChange        ExternalConfigDisplayValues = "absolute_change"
	ActualsOnly           ExternalConfigDisplayValues = "actuals_only"
	PercentageChange      ExternalConfigDisplayValues = "percentage_change"
)

// Defines values for ExternalConfigSortDimensions.
const (
	ExternalConfigSortDimensionsAToZ ExternalConfigSortDimensions = "a_to_z"
	ExternalConfigSortDimensionsAsc  ExternalConfigSortDimensions = "asc"
	ExternalConfigSortDimensionsDesc ExternalConfigSortDimensions = "desc"
)

// Defines values for ExternalConfigSortGroups.
const (
	ExternalConfigSortGroupsAToZ ExternalConfigSortGroups = "a_to_z"
	ExternalConfigSortGroupsAsc  ExternalConfigSortGroups = "asc"
	ExternalConfigSortGroupsDesc ExternalConfigSortGroups = "desc"
)

// Defines values for ExternalConfigTimeInterval.
const (
	ExternalConfigTimeIntervalDay       ExternalConfigTimeInterval = "day"
	ExternalConfigTimeIntervalDayCumSum ExternalConfigTimeInterval = "dayCumSum"
	ExternalConfigTimeIntervalHour      ExternalConfigTimeInterval = "hour"
	ExternalConfigTimeIntervalIsoweek   ExternalConfigTimeInterval = "isoweek"
	ExternalConfigTimeIntervalMonth     ExternalConfigTimeInterval = "month"
	ExternalConfigTimeIntervalQuarter   ExternalConfigTimeInterval = "quarter"
	ExternalConfigTimeIntervalWeek      ExternalConfigTimeInterval = "week"
	ExternalConfigTimeIntervalWeekDay   ExternalConfigTimeInterval = "week_day"
	ExternalConfigTimeIntervalYear      ExternalConfigTimeInterval = "year"
)

// Defines values for ExternalConfigFilterMode.
const (
	ExternalConfigFilterModeContains   ExternalConfigFilterMode = "contains"
	ExternalConfigFilterModeEndsWith   ExternalConfigFilterMode = "ends_with"
	ExternalConfigFilterModeIs         ExternalConfigFilterMode = "is"
	ExternalConfigFilterModeRegexp     ExternalConfigFilterMode = "regexp"
	ExternalConfigFilterModeStartsWith ExternalConfigFilterMode = "starts_with"
)

// Defines values for ExternalConfigMetricFilterOperator.
const (
	ExternalConfigMetricFilterOperatorB   ExternalConfigMetricFilterOperator = "b"
	ExternalConfigMetricFilterOperatorE   ExternalConfigMetricFilterOperator = "e"
	ExternalConfigMetricFilterOperatorGt  ExternalConfigMetricFilterOperator = "gt"
	ExternalConfigMetricFilterOperatorGte ExternalConfigMetricFilterOperator = "gte"
	ExternalConfigMetricFilterOperatorLt  ExternalConfigMetricFilterOperator = "lt"
	ExternalConfigMetricFilterOperatorLte ExternalConfigMetricFilterOperator = "lte"
	ExternalConfigMetricFilterOperatorNb  ExternalConfigMetricFilterOperator = "nb"
	ExternalConfigMetricFilterOperatorNe  ExternalConfigMetricFilterOperator = "ne"
)

// Defines values for ExternalMetricType.
const (
	ExternalMetricTypeBasic    ExternalMetricType = "basic"
	ExternalMetricTypeCustom   ExternalMetricType = "custom"
	ExternalMetricTypeExtended ExternalMetricType = "extended"
)

// Defines values for ExternalOriginType.
const (
	ExternalOriginTypeAttribution      ExternalOriginType = "attribution"
	ExternalOriginTypeAttributionGroup ExternalOriginType = "attribution_group"
	ExternalOriginTypeDatetime         ExternalOriginType = "datetime"
	ExternalOriginTypeFixed            ExternalOriginType = "fixed"
	ExternalOriginTypeGke              ExternalOriginType = "gke"
	ExternalOriginTypeGkeLabel         ExternalOriginType = "gke_label"
	ExternalOriginTypeLabel            ExternalOriginType = "label"
	ExternalOriginTypeOptional         ExternalOriginType = "optional"
	ExternalOriginTypeProjectLabel     ExternalOriginType = "project_label"
	ExternalOriginTypeSystemLabel      ExternalOriginType = "system_label"
	ExternalOriginTypeTag              ExternalOriginType = "tag"
	ExternalOriginTypeUnallocated      ExternalOriginType = "unallocated"
)

// Defines values for ExternalRenderer.
const (
	AreaChart          ExternalRenderer = "area_chart"
	AreaSplineChart    ExternalRenderer = "area_spline_chart"
	BarChart           ExternalRenderer = "bar_chart"
	ColumnChart        ExternalRenderer = "column_chart"
	CsvExport          ExternalRenderer = "csv_export"
	LineChart          ExternalRenderer = "line_chart"
	SheetsExport       ExternalRenderer = "sheets_export"
	SplineChart        ExternalRenderer = "spline_chart"
	StackedAreaChart   ExternalRenderer = "stacked_area_chart"
	StackedBarChart    ExternalRenderer = "stacked_bar_chart"
	StackedColumnChart ExternalRenderer = "stacked_column_chart"
	Table              ExternalRenderer = "table"
	TableColHeatmap    ExternalRenderer = "table_col_heatmap"
	TableHeatmap       ExternalRenderer = "table_heatmap"
	TableRowHeatmap    ExternalRenderer = "table_row_heatmap"
	TreemapChart       ExternalRenderer = "treemap_chart"
)

// Defines values for ExternalReportType.
const (
	ExternalReportTypeCustom  ExternalReportType = "custom"
	ExternalReportTypeManaged ExternalReportType = "managed"
	ExternalReportTypePreset  ExternalReportType = "preset"
)

// Defines values for ExternalSplitMode.
const (
	ExternalSplitModeCustom       ExternalSplitMode = "custom"
	ExternalSplitModeEven         ExternalSplitMode = "even"
	ExternalSplitModeProportional ExternalSplitMode = "proportional"
)

// Defines values for ExternalSplitType.
const (
	ExternalSplitTypeAttribution      ExternalSplitType = "attribution"
	ExternalSplitTypeAttributionGroup ExternalSplitType = "attribution_group"
	ExternalSplitTypeDatetime         ExternalSplitType = "datetime"
	ExternalSplitTypeFixed            ExternalSplitType = "fixed"
	ExternalSplitTypeGke              ExternalSplitType = "gke"
	ExternalSplitTypeGkeLabel         ExternalSplitType = "gke_label"
	ExternalSplitTypeLabel            ExternalSplitType = "label"
	ExternalSplitTypeOptional         ExternalSplitType = "optional"
	ExternalSplitTypeProjectLabel     ExternalSplitType = "project_label"
	ExternalSplitTypeSystemLabel      ExternalSplitType = "system_label"
	ExternalSplitTypeTag              ExternalSplitType = "tag"
)

// Defines values for ExternalSplitTargetType.
const (
	ExternalSplitTargetTypeAttribution      ExternalSplitTargetType = "attribution"
	ExternalSplitTargetTypeAttributionGroup ExternalSplitTargetType = "attribution_group"
	ExternalSplitTargetTypeDatetime         ExternalSplitTargetType = "datetime"
	ExternalSplitTargetTypeFixed            ExternalSplitTargetType = "fixed"
	ExternalSplitTargetTypeGke              ExternalSplitTargetType = "gke"
	ExternalSplitTargetTypeGkeLabel         ExternalSplitTargetType = "gke_label"
	ExternalSplitTargetTypeLabel            ExternalSplitTargetType = "label"
	ExternalSplitTargetTypeOptional         ExternalSplitTargetType = "optional"
	ExternalSplitTargetTypeProjectLabel     ExternalSplitTargetType = "project_label"
	ExternalSplitTargetTypeSystemLabel      ExternalSplitTargetType = "system_label"
	ExternalSplitTargetTypeTag              ExternalSplitTargetType = "tag"
)

// Defines values for GroupAllocationRuleAction.
const (
	Create GroupAllocationRuleAction = "create"
	Select GroupAllocationRuleAction = "select"
	Update GroupAllocationRuleAction = "update"
)

// Defines values for InvitedUserBodyStatus.
const (
	InvitedUserBodyStatusInvited InvitedUserBodyStatus = "invited"
)

// Defines values for InvoiceListItemStatus.
const (
	OPEN    InvoiceListItemStatus = "OPEN"
	PAID    InvoiceListItemStatus = "PAID"
	PASTDUE InvoiceListItemStatus = "PAST DUE"
)

// Defines values for InvoicePlatform.
const (
	InvoicePlatformAmazonWebServices InvoicePlatform = "amazon-web-services"
	InvoicePlatformGSuite            InvoicePlatform = "g-suite"
	InvoicePlatformGoogleCloud       InvoicePlatform = "google-cloud"
	InvoicePlatformLooker            InvoicePlatform = "looker"
	InvoicePlatformMicrosoftAzure    InvoicePlatform = "microsoft-azure"
	InvoicePlatformNavigator         InvoicePlatform = "navigator"
	InvoicePlatformOffice365         InvoicePlatform = "office-365"
	InvoicePlatformSolve             InvoicePlatform = "solve"
	InvoicePlatformSuperquery        InvoicePlatform = "superquery"
)

// Defines values for LabelAssignmentObjectObjectType.
const (
	LabelAssignmentObjectObjectTypeAlert      LabelAssignmentObjectObjectType = "alert"
	LabelAssignmentObjectObjectTypeAllocation LabelAssignmentObjectObjectType = "allocation"
	LabelAssignmentObjectObjectTypeAnnotation LabelAssignmentObjectObjectType = "annotation"
	LabelAssignmentObjectObjectTypeBudget     LabelAssignmentObjectObjectType = "budget"
	LabelAssignmentObjectObjectTypeMetric     LabelAssignmentObjectObjectType = "metric"
	LabelAssignmentObjectObjectTypeReport     LabelAssignmentObjectObjectType = "report"
)

// Defines values for LabelListItemColor.
const (
	LabelListItemColorApricot    LabelListItemColor = "apricot"
	LabelListItemColorBlue       LabelListItemColor = "blue"
	LabelListItemColorLavender   LabelListItemColor = "lavender"
	LabelListItemColorLime       LabelListItemColor = "lime"
	LabelListItemColorMint       LabelListItemColor = "mint"
	LabelListItemColorPurple     LabelListItemColor = "purple"
	LabelListItemColorRosePink   LabelListItemColor = "rosePink"
	LabelListItemColorSkyBlue    LabelListItemColor = "skyBlue"
	LabelListItemColorSlateGrey  LabelListItemColor = "slateGrey"
	LabelListItemColorSoftYellow LabelListItemColor = "softYellow"
	LabelListItemColorTeal       LabelListItemColor = "teal"
)

// Defines values for LabelListItemType.
const (
	LabelListItemTypeCustom LabelListItemType = "custom"
	LabelListItemTypePreset LabelListItemType = "preset"
)

// Defines values for LimitSort.
const (
	LimitSortAToZ LimitSort = "a_to_z"
	LimitSortAsc  LimitSort = "asc"
	LimitSortDesc LimitSort = "desc"
)

// Defines values for MetricFilterText.
const (
	MetricFilterTextGt MetricFilterText = "gt"
	MetricFilterTextLt MetricFilterText = "lt"
)

// Defines values for NewAllocationResponseType.
const (
	NewAllocationResponseTypeGroup  NewAllocationResponseType = "group"
	NewAllocationResponseTypeSingle NewAllocationResponseType = "single"
)

// Defines values for ReportType.
const (
	ReportTypeCustom ReportType = "custom"
	ReportTypePreset ReportType = "preset"
)

// Defines values for ResourcePermissionRole.
const (
	ResourcePermissionRoleEditor ResourcePermissionRole = "editor"
	ResourcePermissionRoleOwner  ResourcePermissionRole = "owner"
	ResourcePermissionRoleViewer ResourcePermissionRole = "viewer"
)

// Defines values for ResourcePermissionsResponsePublic.
const (
	ResourcePermissionsResponsePublicEditor ResourcePermissionsResponsePublic = "editor"
	ResourcePermissionsResponsePublicViewer ResourcePermissionsResponsePublic = "viewer"
)

// Defines values for RunReportResultResultMlFeatures.
const (
	Decreasing RunReportResultResultMlFeatures = "decreasing"
	Forecast   RunReportResultResultMlFeatures = "forecast"
	Increasing RunReportResultResultMlFeatures = "increasing"
	None       RunReportResultResultMlFeatures = "none"
)

// Defines values for TicketExtAPIPlatform.
const (
	TicketExtAPIPlatformAmazonWebServices   TicketExtAPIPlatform = "amazon_web_services"
	TicketExtAPIPlatformDoit                TicketExtAPIPlatform = "doit"
	TicketExtAPIPlatformGoogleCloudPlatform TicketExtAPIPlatform = "google_cloud_platform"
	TicketExtAPIPlatformMicrosoftAzure      TicketExtAPIPlatform = "microsoft_azure"
)

// Defines values for TicketExtAPISeverity.
const (
	TicketExtAPISeverityHigh   TicketExtAPISeverity = "high"
	TicketExtAPISeverityLow    TicketExtAPISeverity = "low"
	TicketExtAPISeverityNormal TicketExtAPISeverity = "normal"
	TicketExtAPISeverityUrgent TicketExtAPISeverity = "urgent"
)

// Defines values for TicketListItemPlatform.
const (
	TicketListItemPlatformAmazonWebServices   TicketListItemPlatform = "amazon_web_services"
	TicketListItemPlatformDoit                TicketListItemPlatform = "doit"
	TicketListItemPlatformGoogleCloudPlatform TicketListItemPlatform = "google_cloud_platform"
	TicketListItemPlatformMicrosoftAzure      TicketListItemPlatform = "microsoft_azure"
)

// Defines values for TicketResponseExtAPIPlatform.
const (
	AmazonWebServices   TicketResponseExtAPIPlatform = "amazon_web_services"
	Doit                TicketResponseExtAPIPlatform = "doit"
	GoogleCloudPlatform TicketResponseExtAPIPlatform = "google_cloud_platform"
	MicrosoftAzure      TicketResponseExtAPIPlatform = "microsoft_azure"
)

// Defines values for TicketResponseExtAPISeverity.
const (
	TicketResponseExtAPISeverityHigh   TicketResponseExtAPISeverity = "high"
	TicketResponseExtAPISeverityLow    TicketResponseExtAPISeverity = "low"
	TicketResponseExtAPISeverityNormal TicketResponseExtAPISeverity = "normal"
	TicketResponseExtAPISeverityUrgent TicketResponseExtAPISeverity = "urgent"
)

// Defines values for TimeSettingsMode.
const (
	Current TimeSettingsMode = "current"
	Custom  TimeSettingsMode = "custom"
	Last    TimeSettingsMode = "last"
)

// Defines values for TimeSettingsUnit.
const (
	Day     TimeSettingsUnit = "day"
	Month   TimeSettingsUnit = "month"
	Quarter TimeSettingsUnit = "quarter"
	Week    TimeSettingsUnit = "week"
	Year    TimeSettingsUnit = "year"
)

// Defines values for UpdateLabelRequestColor.
const (
	Apricot    UpdateLabelRequestColor = "apricot"
	Blue       UpdateLabelRequestColor = "blue"
	Lavender   UpdateLabelRequestColor = "lavender"
	Lime       UpdateLabelRequestColor = "lime"
	Mint       UpdateLabelRequestColor = "mint"
	Purple     UpdateLabelRequestColor = "purple"
	RosePink   UpdateLabelRequestColor = "rosePink"
	SkyBlue    UpdateLabelRequestColor = "skyBlue"
	SlateGrey  UpdateLabelRequestColor = "slateGrey"
	SoftYellow UpdateLabelRequestColor = "softYellow"
	Teal       UpdateLabelRequestColor = "teal"
)

// Defines values for UpdateUserRequestJobFunction.
const (
	UpdateUserRequestJobFunctionDataEngineerDataAnalysts UpdateUserRequestJobFunction = "Data Engineer / Data Analysts"
	UpdateUserRequestJobFunctionExecutiveTeam            UpdateUserRequestJobFunction = "Executive Team"
	UpdateUserRequestJobFunctionFinanceAccounting        UpdateUserRequestJobFunction = "Finance / Accounting"
	UpdateUserRequestJobFunctionFounder                  UpdateUserRequestJobFunction = "Founder"
	UpdateUserRequestJobFunctionLegalPurchasing          UpdateUserRequestJobFunction = "Legal / Purchasing"
	UpdateUserRequestJobFunctionManagement               UpdateUserRequestJobFunction = "Management"
	UpdateUserRequestJobFunctionSalesMarketing           UpdateUserRequestJobFunction = "Sales / Marketing"
	UpdateUserRequestJobFunctionSoftwareOpsEngineer      UpdateUserRequestJobFunction = "Software / Ops Engineer"
)

// Defines values for UpdateUserRequestLanguage.
const (
	UpdateUserRequestLanguageEn UpdateUserRequestLanguage = "en"
	UpdateUserRequestLanguageJa UpdateUserRequestLanguage = "ja"
)

// Defines values for UpdatedUserBodyJobFunction.
const (
	UpdatedUserBodyJobFunctionDataEngineerDataAnalysts UpdatedUserBodyJobFunction = "Data Engineer / Data Analysts"
	UpdatedUserBodyJobFunctionExecutiveTeam            UpdatedUserBodyJobFunction = "Executive Team"
	UpdatedUserBodyJobFunctionFinanceAccounting        UpdatedUserBodyJobFunction = "Finance / Accounting"
	UpdatedUserBodyJobFunctionFounder                  UpdatedUserBodyJobFunction = "Founder"
	UpdatedUserBodyJobFunctionLegalPurchasing          UpdatedUserBodyJobFunction = "Legal / Purchasing"
	UpdatedUserBodyJobFunctionManagement               UpdatedUserBodyJobFunction = "Management"
	UpdatedUserBodyJobFunctionSalesMarketing           UpdatedUserBodyJobFunction = "Sales / Marketing"
	UpdatedUserBodyJobFunctionSoftwareOpsEngineer      UpdatedUserBodyJobFunction = "Software / Ops Engineer"
)

// Defines values for UpdatedUserBodyLanguage.
const (
	UpdatedUserBodyLanguageEn UpdatedUserBodyLanguage = "en"
	UpdatedUserBodyLanguageJa UpdatedUserBodyLanguage = "ja"
)

// Defines values for UserListItemJobFunction.
const (
	DataEngineerDataAnalysts UserListItemJobFunction = "Data Engineer / Data Analysts"
	ExecutiveTeam            UserListItemJobFunction = "Executive Team"
	FinanceAccounting        UserListItemJobFunction = "Finance / Accounting"
	Founder                  UserListItemJobFunction = "Founder"
	LegalPurchasing          UserListItemJobFunction = "Legal / Purchasing"
	Management               UserListItemJobFunction = "Management"
	SalesMarketing           UserListItemJobFunction = "Sales / Marketing"
	SoftwareOpsEngineer      UserListItemJobFunction = "Software / Ops Engineer"
)

// Defines values for UserListItemLanguage.
const (
	En UserListItemLanguage = "en"
	Ja UserListItemLanguage = "ja"
)

// Defines values for UserListItemStatus.
const (
	UserListItemStatusActive  UserListItemStatus = "active"
	UserListItemStatusInvited UserListItemStatus = "invited"
)

// Defines values for ResourceType.
const (
	ResourceTypeAlerts            ResourceType = "alerts"
	ResourceTypeAllocations       ResourceType = "allocations"
	ResourceTypeAttributiongroups ResourceType = "attributiongroups"
	ResourceTypeAttributions      ResourceType = "attributions"
	ResourceTypeBudgets           ResourceType = "budgets"
	ResourceTypeReports           ResourceType = "reports"
)

// Defines values for SortOrder.
const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

// Defines values for ListAlertsParamsSortBy.
const (
	ListAlertsParamsSortByCreateTime  ListAlertsParamsSortBy = "createTime"
	ListAlertsParamsSortByLastAlerted ListAlertsParamsSortBy = "lastAlerted"
	ListAlertsParamsSortByName        ListAlertsParamsSortBy = "name"
	ListAlertsParamsSortByUpdateTime  ListAlertsParamsSortBy = "updateTime"
)

// Defines values for ListAlertsParamsSortOrder.
const (
	ListAlertsParamsSortOrderAsc  ListAlertsParamsSortOrder = "asc"
	ListAlertsParamsSortOrderDesc ListAlertsParamsSortOrder = "desc"
)

// Defines values for ListAllocationsParamsSortBy.
const (
	ListAllocationsParamsSortByCreateTime  ListAllocationsParamsSortBy = "createTime"
	ListAllocationsParamsSortByDescription ListAllocationsParamsSortBy = "description"
	ListAllocationsParamsSortById          ListAllocationsParamsSortBy = "id"
	ListAllocationsParamsSortByName        ListAllocationsParamsSortBy = "name"
	ListAllocationsParamsSortByOwner       ListAllocationsParamsSortBy = "owner"
	ListAllocationsParamsSortByType        ListAllocationsParamsSortBy = "type"
	ListAllocationsParamsSortByUpdateTime  ListAllocationsParamsSortBy = "updateTime"
)

// Defines values for ListAllocationsParamsSortOrder.
const (
	ListAllocationsParamsSortOrderAsc  ListAllocationsParamsSortOrder = "asc"
	ListAllocationsParamsSortOrderDesc ListAllocationsParamsSortOrder = "desc"
)

// Defines values for ListAnnotationsParamsSortBy.
const (
	ListAnnotationsParamsSortByContent      ListAnnotationsParamsSortBy = "content"
	ListAnnotationsParamsSortById           ListAnnotationsParamsSortBy = "id"
	ListAnnotationsParamsSortByTimeCreated  ListAnnotationsParamsSortBy = "timeCreated"
	ListAnnotationsParamsSortByTimeModified ListAnnotationsParamsSortBy = "timeModified"
	ListAnnotationsParamsSortByTimestamp    ListAnnotationsParamsSortBy = "timestamp"
)

// Defines values for ListAnnotationsParamsSortOrder.
const (
	ListAnnotationsParamsSortOrderAsc  ListAnnotationsParamsSortOrder = "asc"
	ListAnnotationsParamsSortOrderDesc ListAnnotationsParamsSortOrder = "desc"
)

// Defines values for ListAttributionGroupsParamsSortBy.
const (
	ListAttributionGroupsParamsSortByCreateTime  ListAttributionGroupsParamsSortBy = "createTime"
	ListAttributionGroupsParamsSortByDescription ListAttributionGroupsParamsSortBy = "description"
	ListAttributionGroupsParamsSortByName        ListAttributionGroupsParamsSortBy = "name"
	ListAttributionGroupsParamsSortByOwner       ListAttributionGroupsParamsSortBy = "owner"
	ListAttributionGroupsParamsSortByType        ListAttributionGroupsParamsSortBy = "type"
	ListAttributionGroupsParamsSortByUpdateTime  ListAttributionGroupsParamsSortBy = "updateTime"
)

// Defines values for ListAttributionGroupsParamsSortOrder.
const (
	ListAttributionGroupsParamsSortOrderAsc  ListAttributionGroupsParamsSortOrder = "asc"
	ListAttributionGroupsParamsSortOrderDesc ListAttributionGroupsParamsSortOrder = "desc"
)

// Defines values for ListAttributionsParamsSortBy.
const (
	ListAttributionsParamsSortByCreateTime  ListAttributionsParamsSortBy = "createTime"
	ListAttributionsParamsSortByDescription ListAttributionsParamsSortBy = "description"
	ListAttributionsParamsSortByName        ListAttributionsParamsSortBy = "name"
	ListAttributionsParamsSortByOwner       ListAttributionsParamsSortBy = "owner"
	ListAttributionsParamsSortByType        ListAttributionsParamsSortBy = "type"
	ListAttributionsParamsSortByUpdateTime  ListAttributionsParamsSortBy = "updateTime"
)

// Defines values for ListAttributionsParamsSortOrder.
const (
	ListAttributionsParamsSortOrderAsc  ListAttributionsParamsSortOrder = "asc"
	ListAttributionsParamsSortOrderDesc ListAttributionsParamsSortOrder = "desc"
)

// Defines values for ListCommitmentsParamsSortBy.
const (
	ListCommitmentsParamsSortByCreateTime ListCommitmentsParamsSortBy = "createTime"
	ListCommitmentsParamsSortByEndDate    ListCommitmentsParamsSortBy = "endDate"
	ListCommitmentsParamsSortByName       ListCommitmentsParamsSortBy = "name"
	ListCommitmentsParamsSortByProvider   ListCommitmentsParamsSortBy = "provider"
	ListCommitmentsParamsSortByStartDate  ListCommitmentsParamsSortBy = "startDate"
	ListCommitmentsParamsSortByUpdateTime ListCommitmentsParamsSortBy = "updateTime"
)

// Defines values for ListCommitmentsParamsSortOrder.
const (
	ListCommitmentsParamsSortOrderAsc  ListCommitmentsParamsSortOrder = "asc"
	ListCommitmentsParamsSortOrderDesc ListCommitmentsParamsSortOrder = "desc"
)

// Defines values for ListDimensionsParamsSortBy.
const (
	ListDimensionsParamsSortByKey       ListDimensionsParamsSortBy = "key"
	ListDimensionsParamsSortByLabel     ListDimensionsParamsSortBy = "label"
	ListDimensionsParamsSortByTimestamp ListDimensionsParamsSortBy = "timestamp"
	ListDimensionsParamsSortByType      ListDimensionsParamsSortBy = "type"
)

// Defines values for ListDimensionsParamsSortOrder.
const (
	ListDimensionsParamsSortOrderAsc  ListDimensionsParamsSortOrder = "asc"
	ListDimensionsParamsSortOrderDesc ListDimensionsParamsSortOrder = "desc"
)

// Defines values for ListLabelsParamsSortBy.
const (
	ListLabelsParamsSortByCreateTime ListLabelsParamsSortBy = "createTime"
	ListLabelsParamsSortById         ListLabelsParamsSortBy = "id"
	ListLabelsParamsSortByName       ListLabelsParamsSortBy = "name"
	ListLabelsParamsSortByType       ListLabelsParamsSortBy = "type"
	ListLabelsParamsSortByUpdateTime ListLabelsParamsSortBy = "updateTime"
)

// Defines values for ListLabelsParamsSortOrder.
const (
	ListLabelsParamsSortOrderAsc  ListLabelsParamsSortOrder = "asc"
	ListLabelsParamsSortOrderDesc ListLabelsParamsSortOrder = "desc"
)

// Defines values for DatahubEventsJSONBodyEventsDimensionsType.
const (
	Fixed        DatahubEventsJSONBodyEventsDimensionsType = "fixed"
	Label        DatahubEventsJSONBodyEventsDimensionsType = "label"
	ProjectLabel DatahubEventsJSONBodyEventsDimensionsType = "project_label"
	SystemLabel  DatahubEventsJSONBodyEventsDimensionsType = "system_label"
)

// Defines values for GetResourcePermissionParamsResourceType.
const (
	GetResourcePermissionParamsResourceTypeAlerts            GetResourcePermissionParamsResourceType = "alerts"
	GetResourcePermissionParamsResourceTypeAllocations       GetResourcePermissionParamsResourceType = "allocations"
	GetResourcePermissionParamsResourceTypeAttributiongroups GetResourcePermissionParamsResourceType = "attributiongroups"
	GetResourcePermissionParamsResourceTypeAttributions      GetResourcePermissionParamsResourceType = "attributions"
	GetResourcePermissionParamsResourceTypeBudgets           GetResourcePermissionParamsResourceType = "budgets"
	GetResourcePermissionParamsResourceTypeReports           GetResourcePermissionParamsResourceType = "reports"
)

// Defines values for UpdateResourcePermissionParamsResourceType.
const (
	Alerts            UpdateResourcePermissionParamsResourceType = "alerts"
	Allocations       UpdateResourcePermissionParamsResourceType = "allocations"
	Attributiongroups UpdateResourcePermissionParamsResourceType = "attributiongroups"
	Attributions      UpdateResourcePermissionParamsResourceType = "attributions"
	Budgets           UpdateResourcePermissionParamsResourceType = "budgets"
	Reports           UpdateResourcePermissionParamsResourceType = "reports"
)

// Defines values for UpdateResourcePermissionJSONBodyPublic.
const (
	UpdateResourcePermissionJSONBodyPublicEditor UpdateResourcePermissionJSONBodyPublic = "editor"
	UpdateResourcePermissionJSONBodyPublicViewer UpdateResourcePermissionJSONBodyPublic = "viewer"
)

// AccountManagerListItem Information of a DoiT account manager assigned to your organization.
type AccountManagerListItem struct {
	CalendlyLink *string `json:"calendlyLink,omitempty"`
	Email        *string `json:"email,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Role         *string `json:"role,omitempty"`
}

// AdvancedAnalysis Advanced analysis options. Each can be set independently.
type AdvancedAnalysis struct {
	Forecast     *bool `json:"forecast,omitempty"`
	NotTrending  *bool `json:"notTrending,omitempty"`
	TrendingDown *bool `json:"trendingDown,omitempty"`
	TrendingUp   *bool `json:"trendingUp,omitempty"`
}

// Alert Configuration and runtime metadata of an alert.
type Alert struct {
	// Config Parameters that define when and how an alert is evaluated.
	Config *AlertConfig `json:"config,omitempty"`

	// CreateTime The time when the alert was created (in UNIX timestamp).
	CreateTime *int64 `json:"createTime,omitempty"`

	// Id Alert ID.
	Id *string `json:"id,omitempty"`

	// LastAlerted Last time the alert was triggered (in UNIX timestamp).
	LastAlerted *int64 `json:"lastAlerted,omitempty"`

	// Name Alert Name.
	Name string `json:"name"`

	// Recipients List of emails that will be notified when the alert is triggered.
	Recipients *[]string `json:"recipients,omitempty"`

	// UpdateTime Last time the alert was modified (in UNIX timestamp).
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// AlertConfig Parameters that define when and how an alert is evaluated.
type AlertConfig struct {
	// Attributions Use 'scopes' instead. The attributions selected define the scope to monitor.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Attributions *[]string `json:"attributions,omitempty"`

	// Condition Condition key or expression used in alert configurations.
	Condition *Condition `json:"condition,omitempty"`

	// Currency Currency code for monetary values.
	Currency   *Currency `json:"currency,omitempty"`
	DataSource *string   `json:"dataSource,omitempty"`

	// EvaluateForEach Add a dimension to break down the evaluation of the condition. For example, evaluate a condition over an attribution for each "Service".
	EvaluateForEach *string `json:"evaluateForEach,omitempty"`

	// Metric Define how metrics are selected and filtered in reports.
	Metric MetricConfig `json:"metric"`

	// Operator Text/operator used to filter metric values in metric filters.
	Operator *MetricFilterText `json:"operator,omitempty"`

	// Scopes The filters selected define the scope of the alert.
	Scopes *[]ExternalConfigFilter `json:"scopes,omitempty"`

	// TimeInterval The time interval to evaluate the condition.
	TimeInterval AlertConfigTimeInterval `json:"timeInterval"`
	Value        float64                 `json:"value"`
}

// AlertConfigTimeInterval The time interval to evaluate the condition.
type AlertConfigTimeInterval string

// AlertRequest Request body for creating a new alert.
type AlertRequest struct {
	// Config Parameters that define when and how an alert is evaluated.
	Config AlertConfig `json:"config"`

	// Name Name of the alert.
	Name string `json:"name"`

	// Recipients List of emails to notify when the alert is triggered.
	Recipients *[]string `json:"recipients,omitempty"`
}

// AlertThreshold A numeric or percentage threshold.
type AlertThreshold struct {
	Amount     *float64 `json:"amount,omitempty"`
	Percentage *float64 `json:"percentage,omitempty"`
}

// AlertUpdateRequest Request body for modifying an existing alert.
type AlertUpdateRequest struct {
	// Config Parameters that define when and how an alert is evaluated.
	Config AlertConfig `json:"config"`

	// Name Alert name
	Name *string `json:"name,omitempty"`

	// Recipients List of emails to notify when the alert is triggered.
	Recipients *[]string `json:"recipients,omitempty"`
}

// Allocation Allocation object, including rules and metadata.
type Allocation struct {
	// AllocationType Composition type of allocation.
	AllocationType *AllocationAllocationType `json:"allocationType,omitempty"`

	// AnomalyDetection Whether anomaly detection is enabled for this allocation.
	AnomalyDetection *bool `json:"anomalyDetection"`

	// CreateTime The time when the allocation was created (in UNIX timestamp).
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description Allocation description.
	Description *string `json:"description,omitempty"`

	// Id Allocation ID.
	Id *string `json:"id,omitempty"`

	// Name Allocation name.
	Name *string `json:"name,omitempty"`

	// Rule Single allocation rule.
	Rule  *AllocationRule        `json:"rule"`
	Rules *[]GroupAllocationRule `json:"rules,omitempty"`

	// Type Type of allocation (preset or custom).
	Type *string `json:"type,omitempty"`

	// UnallocatedCosts Custom label for values that do not fit into allocation (required for group type allocation).
	UnallocatedCosts *string `json:"unallocatedCosts"`

	// UpdateTime Last time the allocation was modified (in UNIX timestamp).
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// AllocationAllocationType Composition type of allocation.
type AllocationAllocationType string

// AllocationComponent A filter component used inside allocation rules.
type AllocationComponent struct {
	// IncludeNull Include null values.
	IncludeNull *bool `json:"include_null,omitempty"`

	// InverseSelection If true, all selected values will be excluded.
	InverseSelection *bool `json:"inverse_selection,omitempty"`

	// Key Key of an existing dimension. Examples: "billing_account_id", "country".
	Key string `json:"key"`

	// Mode Filter mode to apply.
	Mode AllocationComponentMode `json:"mode"`

	// Type Enumeration of supported dimension/filter types.
	Type   DimensionsTypes `json:"type"`
	Values []string        `json:"values"`
}

// AllocationComponentMode Filter mode to apply.
type AllocationComponentMode string

// AllocationDeleteValidation Details about why an allocation cannot be deleted.
type AllocationDeleteValidation struct {
	// Error Error message explaining why deletion failed.
	Error *string `json:"error,omitempty"`

	// Id Allocation ID.
	Id *string `json:"id,omitempty"`

	// Resources Map of resources using this allocation, keyed by resource type.
	Resources *map[string][]ResourceReference `json:"resources,omitempty"`

	// Type Type of allocation.
	Type *AllocationDeleteValidationType `json:"type,omitempty"`
}

// AllocationDeleteValidationType Type of allocation.
type AllocationDeleteValidationType string

// AllocationListItem Summary information for an allocation.
type AllocationListItem struct {
	// AllocationType Composition type of allocation (single or group).
	AllocationType *AllocationListItemAllocationType `json:"allocationType,omitempty"`

	// CreateTime The time when the allocation was created (in UNIX timestamp).
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description Allocation description.
	Description *string `json:"description,omitempty"`

	// Id Allocation ID.
	Id *string `json:"id,omitempty"`

	// Name Allocation name.
	Name *string `json:"name,omitempty"`

	// Owner Allocation owner.
	Owner *string `json:"owner,omitempty"`

	// Type Type of allocation (preset or custom).
	Type *string `json:"type,omitempty"`

	// UpdateTime Last time the allocation was modified (in UNIX timestamp).
	UpdateTime *int64 `json:"updateTime,omitempty"`

	// UrlUI URL to view the allocation in the DoiT console.
	UrlUI *string `json:"urlUI,omitempty"`
}

// AllocationListItemAllocationType Composition type of allocation (single or group).
type AllocationListItemAllocationType string

// AllocationRule Single allocation rule.
type AllocationRule struct {
	// Components List of allocation filter components.
	Components []AllocationComponent `json:"components"`

	// Formula Formula for combining components (A is the first component, B is the second one, etc.).
	Formula string `json:"formula"`
}

// AnnotationListItem Summary information about an annotation.
type AnnotationListItem struct {
	// Content The content of the annotation.
	Content string `json:"content"`

	// CreateTime The creation time of the annotation.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// Id The unique identifier of the annotation.
	Id string `json:"id"`

	// Labels List of labels associated with the annotation.
	Labels *[]LabelInfo `json:"labels,omitempty"`

	// Reports List of report IDs associated with the annotation.
	Reports *[]string `json:"reports,omitempty"`

	// Timestamp The date associated with the annotation.
	Timestamp time.Time `json:"timestamp"`

	// UpdateTime The time when the annotation was last updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
}

// AnomaliesResponse List of detected cloud cost anomalies.
type AnomaliesResponse struct {
	Anomalies *[]AnomalyItem `json:"anomalies,omitempty"`
	PageToken *string        `json:"pageToken,omitempty"`
	RowCount  *int64         `json:"rowCount,omitempty"`
}

// AnomalyItem Detailed information about a detected anomaly.
type AnomalyItem struct {
	// Acknowledged Has the anomaly been acknowledged
	Acknowledged *bool `json:"acknowledged,omitempty"`

	// Attribution Attribution ID.
	Attribution string `json:"attribution"`

	// BillingAccount Billing account ID.
	BillingAccount string `json:"billingAccount"`

	// CostOfAnomaly Cost of the anomaly over and above the expected normal cost.
	CostOfAnomaly float64 `json:"costOfAnomaly"`

	// EndTime End of the anomaly.
	EndTime *int    `json:"endTime"`
	Id      *string `json:"id,omitempty"`

	// Platform Cloud Provider name.
	Platform string `json:"platform"`

	// ResourceData Array of resources contributing to an anomaly.
	ResourceData *AnomalyResourceArray `json:"resourceData,omitempty"`

	// Scope Scope: Project or Account
	Scope string `json:"scope"`

	// ServiceName Service name.
	ServiceName string `json:"serviceName"`

	// SeverityLevel Severity level: Information, Warning or Critical
	SeverityLevel string `json:"severityLevel"`

	// StartTime Usage start time of the anomaly.
	StartTime int64              `json:"startTime"`
	Status    *AnomalyItemStatus `json:"status"`

	// TimeFrame Timeframe: Daily or Hourly
	TimeFrame string `json:"timeFrame"`

	// Top3SKUs Array of SKU entries contributing to an anomaly.
	Top3SKUs AnomalySKUArray `json:"top3SKUs"`
}

// AnomalyItemStatus defines model for AnomalyItem.Status.
type AnomalyItemStatus string

// AnomalyResource Resource-specific contribution to an anomaly.
type AnomalyResource struct {
	Cost *float64 `json:"cost,omitempty"`

	// Operation For anomalies related to AWS S3
	Operation      *string `json:"operation,omitempty"`
	ResourceId     *string `json:"resourceId,omitempty"`
	SkuDescription *string `json:"skuDescription,omitempty"`
}

// AnomalyResourceArray Array of resources contributing to an anomaly.
type AnomalyResourceArray = []AnomalyResource

// AnomalySKU SKU-level information contributing to an anomaly.
type AnomalySKU struct {
	Cost *float64 `json:"cost,omitempty"`
	Name *string  `json:"name,omitempty"`
}

// AnomalySKUArray Array of SKU entries contributing to an anomaly.
type AnomalySKUArray = []AnomalySKU

// AssetItem Detailed information about a single asset.
type AssetItem struct {
	// CreateTime The time when the asset was created, in milliseconds since the epoch.
	CreateTime *int64  `json:"createTime,omitempty"`
	Id         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
	Quantity   *int64  `json:"quantity,omitempty"`
	Type       *string `json:"type,omitempty"`
	Url        *string `json:"url,omitempty"`
}

// AssetProperties Additional properties associated with an asset.
type AssetProperties struct {
	CustomerDomain *string `json:"customerDomain,omitempty"`
	CustomerID     *string `json:"customerID,omitempty"`
	Reseller       *string `json:"reseller,omitempty"`

	// Subscription Subscription-related metadata for an asset.
	Subscription *Subscription `json:"subscription,omitempty"`
}

// AssetResponse Response returned after creating or updating an asset.
type AssetResponse struct {
	AccountID *string `json:"accountID,omitempty"`
}

// AssignObjectsToLabelRequest Request to assign or remove objects from a label.
type AssignObjectsToLabelRequest struct {
	// Add Array of objects to assign to the label.
	Add *[]LabelAssignmentObject `json:"add,omitempty"`

	// Remove Array of objects to unassign from the label.
	Remove *[]LabelAssignmentObject `json:"remove,omitempty"`
}

// AttributionAPI Definition and metadata of an attribution.
type AttributionAPI struct {
	// AnomalyDetection Indicates if the attribution has an active anomaly detection.
	AnomalyDetection *bool `json:"anomalyDetection,omitempty"`

	// Components List of Attribution filters
	Components *[]AttributionComponent `json:"components,omitempty"`

	// CreateTime Creation time of this Attribution (in unix milliseconds)
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description Attribution description
	Description *string `json:"description,omitempty"`

	// Formula Attribution formula (A is the first component, B is the second component, C is the third component, etc.)
	Formula *string `json:"formula,omitempty"`

	// Id attribution ID, identifying the attribution
	// in:path
	Id *string `json:"id,omitempty"`

	// Name Attribution Name
	Name string `json:"name"`

	// Type Type of Attribution can be either "preset" or "custom"
	Type *string `json:"type,omitempty"`

	// UpdateTime Last time somebody modified this Attribution (in unix milliseconds)
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// AttributionComponent A filter component of an attribution.
type AttributionComponent struct {
	IncludeNull *bool `json:"include_null,omitempty"`

	// InverseSelection If true, all selected values will be excluded.
	InverseSelection *bool `json:"inverse_selection,omitempty"`

	// Key Key of a dimension. Examples: "service_id", "cloud_provider", "sku_description"
	Key string `json:"key"`

	// Regexp Filter the dimension values using a regular expression.
	Regexp *string `json:"regexp,omitempty"`

	// Type Enumeration of supported dimension/filter types.
	Type   DimensionsTypes `json:"type"`
	Values *[]string       `json:"values,omitempty"`
}

// AttributionDeleteValidation Validation result when deleting an attribution.
type AttributionDeleteValidation struct {
	// Error Error message explaining why the deletion failed.
	Error *string `json:"error"`

	// Id ID of the attribution that could not be deleted.
	Id *string `json:"id,omitempty"`

	// Resources Map of resources that block deletion operations.
	Resources *BlockingResources `json:"resources,omitempty"`
}

// AttributionGroupAttributionItem Summary information about an attribution within an attribution group.
type AttributionGroupAttributionItem struct {
	// CreateTime The timestamp when the attribution was created.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description The description of the attribution.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the attribution.
	Id *string `json:"id,omitempty"`

	// Name The name of the attribution.
	Name *string `json:"name,omitempty"`

	// Owner The email of the attribution owner.
	Owner *string `json:"owner,omitempty"`

	// Type Type of attribution can be either preset or custom.
	Type *string `json:"type,omitempty"`

	// UpdateTime The timestamp when the attribution was last updated.
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// AttributionGroupDeleteValidation Validation result when deleting an attribution group.
type AttributionGroupDeleteValidation struct {
	// Error Error message explaining why the deletion failed.
	Error *string `json:"error"`

	// Id ID of the attribution group that could not be deleted.
	Id *string `json:"id,omitempty"`

	// Resources Map of resources that block deletion operations.
	Resources *BlockingResources `json:"resources,omitempty"`
}

// AttributionGroupGetExternal Attribution group returned by the API.
type AttributionGroupGetExternal struct {
	// Attributions Array of attributions in this attribution group.
	Attributions *[]AttributionGroupAttributionItem `json:"attributions,omitempty"`
	Cloud        *[]string                          `json:"cloud,omitempty"`

	// Customer Reference to a Firestore document.
	Customer    *DocumentRef `json:"customer,omitempty"`
	Description *string      `json:"description,omitempty"`
	Id          *string      `json:"id,omitempty"`
	Name        *string      `json:"name,omitempty"`

	// Organization Reference to a Firestore document.
	Organization *DocumentRef `json:"organization,omitempty"`
	TimeCreated  *time.Time   `json:"timeCreated,omitempty"`
	TimeModified *time.Time   `json:"timeModified,omitempty"`

	// Type Generic object type identifier.
	Type *ObjectType `json:"type,omitempty"`
}

// AttributionGroupListItem Summary information about an attribution group.
type AttributionGroupListItem struct {
	// CreateTime The timestamp when the attribution group was created (Unix milliseconds).
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description The description of the attribution group.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the attribution group.
	Id *string `json:"id,omitempty"`

	// Name The name of the attribution group.
	Name *string `json:"name,omitempty"`

	// Owner The email of the attribution group owner.
	Owner *string `json:"owner,omitempty"`

	// Type The type of the attribution group.
	Type *AttributionGroupListItemType `json:"type,omitempty"`

	// UpdateTime The timestamp when the attribution group was last updated (Unix milliseconds).
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// AttributionGroupListItemType The type of the attribution group.
type AttributionGroupListItemType string

// AttributionGroupRequest Request body for creating an attribution group.
type AttributionGroupRequest struct {
	// Attributions List of the attributions that are part of the attribution group.
	Attributions []string `json:"attributions"`

	// Description Description of the attribution group.
	Description *string `json:"description,omitempty"`

	// Name Name of the attribution group.
	Name string `json:"name"`

	// NullFallback Custom label for values that do not fit into attributions.
	NullFallback *string `json:"nullFallback,omitempty"`
}

// AttributionGroupUpdateRequest Request body for updating an attribution group.
type AttributionGroupUpdateRequest struct {
	// Attributions List of the attributions that are part of the attribution group.
	Attributions []string `json:"attributions"`

	// Description Description of the attribution group.
	Description *string `json:"description,omitempty"`

	// Name Name of the attribution group.
	Name string `json:"name"`

	// NullFallback Custom label for values that do not fit into attributions.
	NullFallback *string `json:"nullFallback,omitempty"`
}

// AttributionGroupsListExternal List of attribution groups.
type AttributionGroupsListExternal struct {
	// AttributionGroups Array of AttributionGroup.
	AttributionGroups *[]AttributionGroupListItem `json:"attributionGroups,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results.
	PageToken *string `json:"pageToken,omitempty"`

	// RowCount AttributionGroup rows count.
	RowCount *int64 `json:"rowCount,omitempty"`
}

// AttributionListItem Summary information for an attribution.
type AttributionListItem struct {
	// CreateTime Creation time of the attribution (in unix milliseconds).
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description Attribution description.
	Description *string `json:"description,omitempty"`

	// Id attribution ID, identifying the attribution
	// in:path
	Id *string `json:"id,omitempty"`

	// Name Attribution Name.
	Name string `json:"name"`

	// Owner Attribution owner.
	Owner *string `json:"owner,omitempty"`

	// Type Type of attribution can be either preset or custom.
	Type *string `json:"type,omitempty"`

	// UpdateTime Last time the attribution was modified (in unix milliseconds).
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// BlockingResources Map of resources that block deletion operations.
type BlockingResources struct {
	// Alerts List of alerts using this resource.
	Alerts *[]ResourceReference `json:"alerts,omitempty"`

	// AttributionGroups List of attribution groups using this resource (only applicable for attribution deletion).
	AttributionGroups *[]ResourceReference `json:"attributionGroups,omitempty"`

	// Attributions List of attributions using this resource (only applicable for attribution deletion).
	Attributions *[]ResourceReference `json:"attributions,omitempty"`

	// Budgets List of budgets using this resource.
	Budgets *[]ResourceReference `json:"budgets,omitempty"`

	// Reports List of reports using this resource.
	Reports *[]ResourceReference `json:"reports,omitempty"`
}

// BudgetAPI Budget details and runtime metrics.
type BudgetAPI struct {
	// Alerts List of up to three thresholds defined as a percentage of amount.
	Alerts *[]ExternalBudgetAlert `json:"alerts,omitempty"`

	// Amount Budget period amount
	// required: true(if usePrevSpend is false)
	Amount *float64 `json:"amount,omitempty"`

	// Collaborators List of permitted users to view/edit the report.
	Collaborators *[]Collaborator `json:"collaborators,omitempty"`

	// CreateTime Creation time (in UNIX timestamp).
	CreateTime *int64 `json:"createTime,omitempty"`

	// Currency Currency code for monetary values.
	Currency           Currency `json:"currency"`
	CurrentUtilization *float64 `json:"currentUtilization,omitempty"`

	// Description Budget description.
	Description *string `json:"description,omitempty"`

	// EndPeriod Fixed budget end date (in UNIX timestamp)
	// required: true(if budget type is fixed)
	EndPeriod             *int64   `json:"endPeriod,omitempty"`
	ForecastedUtilization *float64 `json:"forecastedUtilization,omitempty"`

	// GrowthPerPeriod Periodical growth percentage in recurring budgets.
	GrowthPerPeriod *float64 `json:"growthPerPeriod,omitempty"`

	// Id budget ID, identifying the report
	// in:path
	Id *string `json:"id,omitempty"`

	// Metric Budget metric - currently fixed to "cost"
	Metric *string `json:"metric,omitempty"`

	// Name Budget Name
	Name string `json:"name"`

	// Public Public sharing access level for the budget.
	Public *BudgetAPIPublic `json:"public,omitempty"`

	// Recipients List of emails to notify when reaching alert threshold.
	Recipients *[]string `json:"recipients,omitempty"`

	// RecipientsSlackChannels List of Slack channels to notify when reaching alert threshold.
	RecipientsSlackChannels *[]SlackChannel `json:"recipientsSlackChannels,omitempty"`

	// Scope List of allocations that defines the budget scope.
	Scope *[]string `json:"scope,omitempty"`

	// Scopes The filters selected define the scope of the budget.
	Scopes []ExternalConfigFilter `json:"scopes"`

	// SeasonalAmounts List of seasonal amounts for recurring budgets with different amounts per period.
	SeasonalAmounts *[]float64 `json:"seasonalAmounts,omitempty"`

	// StartPeriod Budget start date (in UNIX timestamp).
	StartPeriod int64 `json:"startPeriod"`

	// TimeInterval Recurring budget interval can be one of: ["day", "week", "month", "quarter" ,"year"]
	TimeInterval string `json:"timeInterval"`

	// Type budget type can be one of: ["fixed", "recurring"]
	Type string `json:"type"`

	// UpdateTime Update time (in UNIX timestamp).
	UpdateTime *int64 `json:"updateTime,omitempty"`

	// UsePrevSpend Use the last period's spend as the target amount for recurring budgets.
	UsePrevSpend *bool `json:"usePrevSpend,omitempty"`
}

// BudgetAPIPublic Public sharing access level for the budget.
type BudgetAPIPublic string

// BudgetCreateUpdateAlert Threshold settings for budget alerts.
type BudgetCreateUpdateAlert struct {
	Percentage *float64 `json:"percentage,omitempty"`
}

// BudgetCreateUpdateRequest Request body for creating or updating a budget.
type BudgetCreateUpdateRequest struct {
	// Alerts List of up to three thresholds defined as a percentage of the amount.
	Alerts *[]BudgetCreateUpdateAlert `json:"alerts,omitempty"`

	// Amount Budget period amount
	// required: true(if usePrevSpend is false)
	Amount *float64 `json:"amount,omitempty"`

	// Collaborators List of permitted users to view/edit the report.
	Collaborators *[]Collaborator `json:"collaborators,omitempty"`

	// Currency Currency code for monetary values.
	Currency *Currency `json:"currency,omitempty"`

	// Description Budget description
	Description *string `json:"description,omitempty"`

	// EndPeriod Fixed budget end date
	// required: true(if budget type is fixed)
	EndPeriod *int64 `json:"endPeriod,omitempty"`

	// GrowthPerPeriod Periodical growth percentage in recurring budget
	GrowthPerPeriod *float64 `json:"growthPerPeriod,omitempty"`

	// Metric Budget metric
	Metric *BudgetCreateUpdateRequestMetric `json:"metric,omitempty"`

	// Name Budget Name.
	Name   *string                          `json:"name,omitempty"`
	Public *BudgetCreateUpdateRequestPublic `json:"public,omitempty"`

	// Recipients List of emails to notify when reaching alert threshold.
	Recipients *[]string `json:"recipients,omitempty"`

	// RecipientsSlackChannels List of Slack channels to notify when reaching alert threshold.
	RecipientsSlackChannels *[]SlackChannel `json:"recipientsSlackChannels,omitempty"`

	// Scope List of allocations that define the budget scope.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Scope *[]string `json:"scope,omitempty"`

	// Scopes The filters selected define the scope of the budget.
	Scopes *[]ExternalConfigFilter `json:"scopes,omitempty"`

	// SeasonalAmounts List of seasonal amounts for recurring budgets with different amounts per period.
	SeasonalAmounts *[]float64 `json:"seasonalAmounts,omitempty"`

	// StartPeriod Budget start Date
	StartPeriod *int64 `json:"startPeriod,omitempty"`

	// TimeInterval Recurring budget interval can be one of: ["day", "week", "month", "quarter", "year"]
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Type budget type can be one of: ["fixed", "recurring"]
	Type *string `json:"type,omitempty"`

	// UsePrevSpend Use the last period's spend as the target amount for recurring budgets
	UsePrevSpend *bool `json:"usePrevSpend,omitempty"`
}

// BudgetCreateUpdateRequestMetric Budget metric
type BudgetCreateUpdateRequestMetric string

// BudgetCreateUpdateRequestPublic defines model for BudgetCreateUpdateRequest.Public.
type BudgetCreateUpdateRequestPublic string

// BudgetListItem Summary information for a budget.
type BudgetListItem struct {
	AlertThresholds           *[]AlertThreshold `json:"alertThresholds,omitempty"`
	Amount                    *float64          `json:"amount,omitempty"`
	BudgetName                *string           `json:"budgetName,omitempty"`
	CreateTime                *int64            `json:"createTime,omitempty"`
	Currency                  *string           `json:"currency,omitempty"`
	CurrentUtilization        *float64          `json:"currentUtilization,omitempty"`
	EndPeriod                 *int64            `json:"endPeriod,omitempty"`
	ForecastedUtilizationDate *int64            `json:"forecastedUtilizationDate,omitempty"`
	Id                        *string           `json:"id,omitempty"`
	Owner                     *string           `json:"owner,omitempty"`

	// Scope List of allocations that define the budget scope.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Scope *[]string `json:"scope,omitempty"`

	// Scopes The filters selected define the scope of the budget.
	Scopes       *[]ExternalConfigFilter `json:"scopes,omitempty"`
	StartPeriod  *int64                  `json:"startPeriod,omitempty"`
	TimeInterval *string                 `json:"timeInterval,omitempty"`
	UpdateTime   *int64                  `json:"updateTime,omitempty"`
	Url          *string                 `json:"url,omitempty"`
}

// CloudIncidentListItem Summary information for a cloud incident.
type CloudIncidentListItem struct {
	// CreateTime The creation time of this cloud incident, in milliseconds since the epoch.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Id The unique cloud incident identifier.
	Id *string `json:"id,omitempty"`

	// Platform The Cloud Platform.
	Platform *CloudIncidentListItemPlatform `json:"platform,omitempty"`

	// Product The name of the product affected by the cloud incident
	Product *string `json:"product,omitempty"`

	// Status The Status of the issue
	Status *CloudIncidentListItemStatus `json:"status,omitempty"`

	// Title Cloud incident name as provided by the cloud platform vendor
	Title *string `json:"title,omitempty"`
}

// CloudIncidentListItemPlatform The Cloud Platform.
type CloudIncidentListItemPlatform string

// CloudIncidentListItemStatus The Status of the issue
type CloudIncidentListItemStatus string

// Collaborator A user or identity that has access to a resource.
type Collaborator struct {
	Email *string           `json:"email,omitempty"`
	Role  *CollaboratorRole `json:"role,omitempty"`
}

// CollaboratorRole defines model for Collaborator.Role.
type CollaboratorRole string

// CollectionRef Reference to a Firestore collection.
type CollectionRef struct {
	// ID The collection identifier.
	ID *string `json:"ID,omitempty"`

	// Parent The root collection.
	Parent *map[string]interface{} `json:"Parent,omitempty"`

	// Path The full resource path of the collection: "projects/P/databases/D/documents..."
	Path *string `json:"Path,omitempty"`
}

// CommitmentExternal A commitment contract.
type CommitmentExternal struct {
	// CreateTime The creation time in milliseconds since epoch.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Currency The currency of the commitment (e.g., USD).
	Currency *string `json:"currency,omitempty"`

	// EndDate The end date of the commitment.
	EndDate *time.Time `json:"endDate,omitempty"`

	// Name The name of the commitment.
	Name *string `json:"name,omitempty"`

	// Periods The list of commitment periods.
	Periods *[]CommitmentPeriod `json:"periods,omitempty"`

	// Provider The cloud provider associated with the commitment.
	Provider *CommitmentExternalProvider `json:"provider,omitempty"`

	// StartDate The start date of the commitment.
	StartDate *time.Time `json:"startDate,omitempty"`

	// TotalCommitmentValue The total value of the commitment across all periods.
	TotalCommitmentValue *float64 `json:"totalCommitmentValue,omitempty"`

	// TotalCurrentAttainment The total current spend attainment across all periods.
	TotalCurrentAttainment *float64 `json:"totalCurrentAttainment,omitempty"`

	// UpdateTime The last update time in milliseconds since epoch.
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// CommitmentExternalProvider The cloud provider associated with the commitment.
type CommitmentExternalProvider string

// CommitmentExternalList List of commitments.
type CommitmentExternalList struct {
	// Commitments Array of commitments.
	Commitments *[]CommitmentExternalListItem `json:"commitments,omitempty"`

	// PageToken Page token. It is used to request a specific page of the list results.
	PageToken *string `json:"pageToken,omitempty"`

	// RowCount The number of returned records.
	RowCount *int64 `json:"rowCount,omitempty"`
}

// CommitmentExternalListItem Summary information of a commitment in a list.
type CommitmentExternalListItem struct {
	// CreateTime The creation time in milliseconds since epoch.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Currency The currency of the commitment.
	Currency *string `json:"currency,omitempty"`

	// EndDate The end date of the commitment.
	EndDate *time.Time `json:"endDate,omitempty"`

	// Name The name of the commitment.
	Name *string `json:"name,omitempty"`

	// Periods The list of commitment periods.
	Periods *[]CommitmentPeriod `json:"periods,omitempty"`

	// Provider The cloud provider associated with the commitment.
	Provider *CommitmentExternalListItemProvider `json:"provider,omitempty"`

	// StartDate The start date of the commitment.
	StartDate *time.Time `json:"startDate,omitempty"`

	// TotalCommitmentValue The total value of the commitment across all periods.
	TotalCommitmentValue *float64 `json:"totalCommitmentValue,omitempty"`

	// TotalCurrentAttainment The total current spend attainment across all periods.
	TotalCurrentAttainment *float64 `json:"totalCurrentAttainment,omitempty"`

	// UpdateTime The last update time in milliseconds since epoch.
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// CommitmentExternalListItemProvider The cloud provider associated with the commitment.
type CommitmentExternalListItemProvider string

// CommitmentPeriod A single period within a commitment.
type CommitmentPeriod struct {
	// CommitmentValue The commitment value for this period.
	CommitmentValue *float64 `json:"commitmentValue,omitempty"`

	// EndDate The end date of the period.
	EndDate *time.Time `json:"endDate,omitempty"`

	// MarketplaceLimitPercentage The marketplace limit as a percentage (0-100).
	MarketplaceLimitPercentage *float64 `json:"marketplaceLimitPercentage,omitempty"`

	// StartDate The start date of the period.
	StartDate *time.Time `json:"startDate,omitempty"`
}

// Condition Condition key or expression used in alert configurations.
type Condition = string

// CreateAllocationRequest Request body for creating an allocation.
type CreateAllocationRequest struct {
	// Description Allocation description.
	Description string `json:"description"`

	// Name Allocation name.
	Name string `json:"name"`

	// Rule Single allocation rule.
	Rule  *AllocationRule        `json:"rule"`
	Rules *[]GroupAllocationRule `json:"rules,omitempty"`

	// UnallocatedCosts Custom label for values that do not fit into allocation (required for group type allocation).
	UnallocatedCosts *string `json:"unallocatedCosts"`
}

// CreateAnnotationRequest Request body to create an annotation.
type CreateAnnotationRequest struct {
	// Content The content of the annotation.
	Content string `json:"content"`

	// Labels List of label IDs to associate with the annotation. Labels must already exist.
	Labels *[]string `json:"labels,omitempty"`

	// Reports List of report IDs associated with the annotation.
	Reports *[]string `json:"reports,omitempty"`

	// Timestamp The date associated with the annotation.
	Timestamp time.Time `json:"timestamp"`
}

// CreateLabelRequest Request body for creating a label.
type CreateLabelRequest struct {
	// Color The color of the label.
	Color CreateLabelRequestColor `json:"color"`

	// Name The name of the label.
	Name string `json:"name"`
}

// CreateLabelRequestColor The color of the label.
type CreateLabelRequestColor string

// Currency Currency code for monetary values.
type Currency string

// DeleteUserResponse Response confirming user deletion.
type DeleteUserResponse struct {
	// Message Success message
	Message *string `json:"message,omitempty"`
}

// Dimension Definition of a report dimension.
type Dimension struct {
	// Id The identifier of the dimension.
	Id *string `json:"id,omitempty"`

	// Type Enumeration of supported dimension/filter types.
	Type *DimensionsTypes `json:"type,omitempty"`
}

// DimensionExternalAPIListItem Summary information about a dimension.
type DimensionExternalAPIListItem struct {
	// Id The identifier of the dimension.
	Id *string `json:"id,omitempty"`

	// Label The label of the dimension.
	Label *string `json:"label,omitempty"`

	// Type Enumeration of supported dimension/filter types.
	Type *DimensionsTypes `json:"type,omitempty"`
}

// DimensionsExternalAPIGetResponse Dimension metadata returned by the API.
type DimensionsExternalAPIGetResponse struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`

	// Type Enumeration of supported dimension/filter types.
	Type   *DimensionsTypes       `json:"type,omitempty"`
	Values *[]ExternalAPIGetValue `json:"values,omitempty"`
}

// DimensionsExternalAPIList Paged list of available dimensions.
type DimensionsExternalAPIList struct {
	// Dimensions Array of dimensions.
	Dimensions *[]DimensionExternalAPIListItem `json:"dimensions,omitempty"`
	PageToken  *string                         `json:"pageToken,omitempty"`
	RowCount   *int64                          `json:"rowCount,omitempty"`
}

// DimensionsTypes Enumeration of supported dimension/filter types.
type DimensionsTypes string

// DocumentRef Reference to a Firestore document.
type DocumentRef struct {
	// ID ID of the document. The last component of the resource path.
	ID *string `json:"ID,omitempty"`

	// Parent Reference to a Firestore collection.
	Parent *CollectionRef `json:"Parent,omitempty"`

	// Path The full resource path of the document. A document "doc-1" in collection "coll-1" would be: "projects/P/databases/D/documents/coll-1/doc-1".
	Path *string `json:"Path,omitempty"`
}

// Error Standard error response structure.
type Error struct {
	// Error Detailed error message.
	Error *string `json:"error,omitempty"`
}

// ExternalAPIGetValue Single value entry used by some dimension endpoints.
type ExternalAPIGetValue struct {
	Cloud *string `json:"cloud,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ExternalAlertList List of alerts.
type ExternalAlertList struct {
	// Alerts Array of alerts.
	Alerts *[]Alert `json:"alerts,omitempty"`

	// PageToken Page token. It is used to request a specific page of the list results.
	PageToken *string `json:"pageToken,omitempty"`

	// RowCount The number of returned records.
	RowCount *int64 `json:"rowCount,omitempty"`
}

// ExternalBudgetAlert Budget alert status details.
type ExternalBudgetAlert struct {
	ForecastedDate *int64   `json:"forecastedDate,omitempty"`
	Percentage     *float64 `json:"percentage,omitempty"`
	Triggered      *bool    `json:"triggered,omitempty"`
}

// ExternalConfig Report configuration.
type ExternalConfig struct {
	// AdvancedAnalysis Advanced analysis options. Each can be set independently.
	AdvancedAnalysis *AdvancedAnalysis `json:"advancedAnalysis,omitempty"`

	// Aggregation How to aggregate data values in the report.
	Aggregation *ExternalConfigAggregation `json:"aggregation,omitempty"`

	// Currency Currency code for monetary values.
	Currency *Currency `json:"currency,omitempty"`

	// CustomTimeRange Required when the time range is set to "custom".
	CustomTimeRange *struct {
		// From The start timestamp of the time range in RFC3339 format.
		From *time.Time `json:"from,omitempty"`

		// To The end timestamp of the time range in RFC3339 format.
		To *time.Time `json:"to,omitempty"`
	} `json:"customTimeRange,omitempty"`

	// DataSource Data source of the report.
	DataSource *ExternalConfigDataSource `json:"dataSource,omitempty"`

	// Dimensions See [Dimensions](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#dimensions).
	Dimensions *[]Dimension `json:"dimensions,omitempty"`

	// DisplayValues See [View data as (Comparative report)](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#view-as).
	DisplayValues *ExternalConfigDisplayValues `json:"displayValues,omitempty"`

	// Filters The filters to apply to the report.
	Filters *[]ExternalConfigFilter `json:"filters,omitempty"`

	// Group The rows that appear in the tabular format of the report. See [Group by](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#group-by).
	Group *[]Group `json:"group,omitempty"`

	// IncludePromotionalCredits Whether to include [promotional credits](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#promotional-credits).
	// If set to **true**, the report must use time interval `month`, `quarter`, or `year`.
	IncludePromotionalCredits *bool `json:"includePromotionalCredits,omitempty"`

	// IncludeSubtotals Whether to include subgroup totals in the report. This option has no impact when reading a report via API.
	IncludeSubtotals *bool `json:"includeSubtotals,omitempty"`

	// Layout Type of visualization or output format.
	Layout *ExternalRenderer `json:"layout,omitempty"`

	// Metric Deprecated: Use 'metrics' instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Metric *ExternalMetric `json:"metric,omitempty"`

	// MetricFilter Metric filter to limit report rows by metric value.
	MetricFilter *ExternalConfigMetricFilter `json:"metricFilter,omitempty"`

	// Metrics The list of metrics to apply to the report. Custom metric can be used only once. Maximum number of metrics is 4.
	Metrics *[]ExternalMetric `json:"metrics,omitempty"`

	// SortDimensions This option has no impact when reading reports via API.
	SortDimensions *ExternalConfigSortDimensions `json:"sortDimensions,omitempty"`

	// SortGroups This option has no impact when reading reports via API.
	SortGroups *ExternalConfigSortGroups `json:"sortGroups,omitempty"`

	// Splits The splits to use in the report.
	Splits *[]ExternalSplit `json:"splits,omitempty"`

	// TimeInterval Time interval for grouping data in the report.
	TimeInterval *ExternalConfigTimeInterval `json:"timeInterval,omitempty"`

	// TimeRange Specify a predefined or custom time range for the report.
	// For example, to specify a custom time range of "last 2 days", set the mode to `last`, the amount to `2`, and the unit to `day`. If `includeCurrent` is `true`, the range will be yesterday and today; otherwise, the range will be yesterday and the day before yesterday.
	// If "custom" type is specified, you need to provide a custom time range in the `customTimeRange` field.
	TimeRange *TimeSettings `json:"timeRange,omitempty"`
}

// ExternalConfigAggregation How to aggregate data values in the report.
type ExternalConfigAggregation string

// ExternalConfigDataSource Data source of the report.
type ExternalConfigDataSource string

// ExternalConfigDisplayValues See [View data as (Comparative report)](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#view-as).
type ExternalConfigDisplayValues string

// ExternalConfigSortDimensions This option has no impact when reading reports via API.
type ExternalConfigSortDimensions string

// ExternalConfigSortGroups This option has no impact when reading reports via API.
type ExternalConfigSortGroups string

// ExternalConfigTimeInterval Time interval for grouping data in the report.
type ExternalConfigTimeInterval string

// ExternalConfigFilter To include or exclude certain values.
// When using attributions as a filter, both the type and the ID must be "attribution", and the values array contains the attribution IDs.
type ExternalConfigFilter struct {
	// Id The field to filter on
	Id string `json:"id"`

	// Inverse Set to `true` to exclude the values.
	Inverse *bool `json:"inverse,omitempty"`

	// Mode Filter mode to apply
	Mode ExternalConfigFilterMode `json:"mode"`

	// Type Enumeration of supported dimension/filter types.
	Type DimensionsTypes `json:"type"`

	// Values Values to filter on.
	Values *[]string `json:"values,omitempty"`
}

// ExternalConfigFilterMode Filter mode to apply
type ExternalConfigFilterMode string

// ExternalConfigMetricFilter Metric filter to limit report rows by metric value.
type ExternalConfigMetricFilter struct {
	// Metric Metric selector used in reports and filters.
	Metric *ExternalMetric `json:"metric,omitempty"`

	// Operator Comparison operator for filtering metric values.
	Operator *ExternalConfigMetricFilterOperator `json:"operator,omitempty"`
	Values   *[]float64                          `json:"values,omitempty"`
}

// ExternalConfigMetricFilterOperator Comparison operator for filtering metric values.
type ExternalConfigMetricFilterOperator string

// ExternalMetric Metric selector used in reports and filters.
type ExternalMetric struct {
	// Type Type of metric to use.
	Type *ExternalMetricType `json:"type,omitempty"`

	// Value For basic metrics, the value can be one of: ["cost", "usage", "savings"]
	// If using custom metrics, the value must refer to an existing custom ID.
	Value *string `json:"value,omitempty"`
}

// ExternalMetricType Type of metric to use.
type ExternalMetricType string

// ExternalOrigin Origin info for cost splitting.
type ExternalOrigin struct {
	// Id ID of the origin.
	Id *string `json:"id,omitempty"`

	// Type Type of the origin.
	// The only supported values at the moment: "attribution", "unallocated"
	Type *ExternalOriginType `json:"type,omitempty"`
}

// ExternalOriginType Type of the origin.
// The only supported values at the moment: "attribution", "unallocated"
type ExternalOriginType string

// ExternalRenderer Type of visualization or output format.
type ExternalRenderer string

// ExternalReport Configuration and metadata of a stored report.
type ExternalReport struct {
	// Config Report configuration.
	Config *ExternalConfig `json:"config,omitempty"`

	// Description Report description.
	Description *string `json:"description,omitempty"`

	// Id Report ID.
	Id *string `json:"id,omitempty"`

	// Name Report name.
	Name string `json:"name"`

	// Type Report type.
	Type *ExternalReportType `json:"type,omitempty"`
}

// ExternalReportType Report type.
type ExternalReportType string

// ExternalSplit Specification of how to split costs.
type ExternalSplit struct {
	// Id ID of the field to split.
	Id *string `json:"id,omitempty"`

	// IncludeOrigin Indicate whether to include the origin.
	IncludeOrigin *bool              `json:"includeOrigin,omitempty"`
	Mode          *ExternalSplitMode `json:"mode,omitempty"`

	// Origin Origin info for cost splitting.
	Origin *ExternalOrigin `json:"origin,omitempty"`

	// Targets Targets for the split.
	Targets *[]ExternalSplitTarget `json:"targets,omitempty"`

	// Type Type of the split.
	// The only supported value at the moment: "attribution_group"
	Type *ExternalSplitType `json:"type,omitempty"`
}

// ExternalSplitMode defines model for ExternalSplit.Mode.
type ExternalSplitMode string

// ExternalSplitType Type of the split.
// The only supported value at the moment: "attribution_group"
type ExternalSplitType string

// ExternalSplitTarget Target and value of a split definition.
type ExternalSplitTarget struct {
	// Id ID of the target.
	Id *string `json:"id,omitempty"`

	// Type Type of the target.
	// The only supported value at the moment: "attribution"
	Type *ExternalSplitTargetType `json:"type,omitempty"`

	// Value Percent of the target, represented in float format. E.g. 30% is 0.3. Required only if the Split Mode is custom.
	Value *float64 `json:"value,omitempty"`
}

// ExternalSplitTargetType Type of the target.
// The only supported value at the moment: "attribution"
type ExternalSplitTargetType string

// ExternalUpdateReport Partial report object used for updates.
type ExternalUpdateReport struct {
	// Config Report configuration.
	Config *ExternalConfig `json:"config,omitempty"`

	// Description Report description
	Description *string `json:"description,omitempty"`

	// Name Report name
	Name *string `json:"name,omitempty"`
}

// Filter An expression for filtering the results. The syntax is `key:[<value>]`. Multiple filters can be connected using a pipe |. See [Filters](https://developer.doit.com/docs/filters).
type Filter = string

// FindCloudDiagramsRequest Request body for locating cloud diagrams for given resource IDs.
type FindCloudDiagramsRequest struct {
	// Resources Resource IDs to find diagrams for.
	Resources []string `json:"resources"`
}

// FindCloudDiagramsResponse List of diagram URLs matching the criteria.
type FindCloudDiagramsResponse = []struct {
	// DiagramUrl URL to the diagram viewer.
	DiagramUrl string `json:"diagramUrl"`

	// ImageUrl URL to the diagram image.
	ImageUrl string `json:"imageUrl"`
}

// Group The dimension that defines a row in the report.
type Group struct {
	// Id Dimension ID.
	Id *string `json:"id,omitempty"`

	// Limit To limit the number of results based on ranking. See [Limit by top/bottom](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#limit-by-topbottom).
	Limit *Limit `json:"limit,omitempty"`

	// Type Enumeration of supported dimension/filter types.
	Type *DimensionsTypes `json:"type,omitempty"`
}

// GroupAllocationRule Allocation rule for a group type allocation.
type GroupAllocationRule struct {
	// Action Action to perform with this rule.
	Action GroupAllocationRuleAction `json:"action"`

	// Components List of allocation filter components (required for 'create' or 'update' action).
	Components *[]AllocationComponent `json:"components,omitempty"`

	// Description Description of the allocation rule.
	Description *string `json:"description,omitempty"`

	// Formula Formula for combining components (A is the first component, B is the second one, etc.)
	Formula *string `json:"formula,omitempty"`

	// Id ID of existing allocation (required for 'update' or 'select' action).
	Id *string `json:"id,omitempty"`

	// Name Name of the allocation rule.
	Name *string `json:"name,omitempty"`
}

// GroupAllocationRuleAction Action to perform with this rule.
type GroupAllocationRuleAction string

// InviteResponse Response returned after creating a user invitation.
type InviteResponse struct {
	// Message Success message
	Message *string          `json:"message,omitempty"`
	User    *InvitedUserBody `json:"user,omitempty"`
}

// InviteUserRequest Request body to invite a new user to the organization.
type InviteUserRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// OrganizationId The ID of the organization to assign the user to.
	OrganizationId *string `json:"organizationId,omitempty"`

	// RoleId The ID of the role to assign to the user.
	RoleId *string `json:"roleId,omitempty"`
}

// InvitedUserBody defines model for InvitedUserBody.
type InvitedUserBody struct {
	// Email The email address of the invited user.
	Email *string `json:"email,omitempty"`

	// Id The unique ID of the invited user.
	Id *string `json:"id,omitempty"`

	// OrganizationId The ID of the organization assigned to the user.
	OrganizationId *string `json:"organizationId,omitempty"`

	// RoleId The ID of the role assigned to the user.
	RoleId *string `json:"roleId,omitempty"`

	// Status The status of the user (invited)
	Status *InvitedUserBodyStatus `json:"status,omitempty"`
}

// InvitedUserBodyStatus The status of the user (invited)
type InvitedUserBodyStatus string

// InvoiceListItem Summary information about an invoice.
type InvoiceListItem struct {
	// BalanceAmount Invoice balance to be paid
	BalanceAmount *float64 `json:"balanceAmount,omitempty"`

	// Currency Currency code for monetary values.
	Currency *Currency `json:"currency,omitempty"`

	// DueDate The last day to pay the invoice, in milliseconds since the epoch
	DueDate *int64 `json:"dueDate,omitempty"`

	// Id Invoice number, identifying the invoice.
	Id *string `json:"id,omitempty"`

	// InvoiceDate The time when this invoice was issued, in milliseconds since the epoch.
	InvoiceDate *int64 `json:"invoiceDate,omitempty"`

	// Platform Platform identifier for invoice source.
	Platform *InvoicePlatform `json:"platform,omitempty"`

	// Status Status of the invoice
	Status *InvoiceListItemStatus `json:"status,omitempty"`

	// TotalAmount Total invoiced amount
	TotalAmount *float64 `json:"totalAmount,omitempty"`

	// Url Link to [invoice details page](https://help.doit.com/docs/billing/invoices-and-payments/managing-invoices) in the DoiT console. You can download the PDF invoice from the invoice details page.
	Url *string `json:"url,omitempty"`
}

// InvoiceListItemStatus Status of the invoice
type InvoiceListItemStatus string

// InvoicePlatform Platform identifier for invoice source.
type InvoicePlatform string

// LabelAssignmentObject Object identifier and type used for label assignments.
type LabelAssignmentObject struct {
	// ObjectId The ID of the object to assign/unassign.
	ObjectId string `json:"objectId"`

	// ObjectType The type of the object.
	ObjectType LabelAssignmentObjectObjectType `json:"objectType"`
}

// LabelAssignmentObjectObjectType The type of the object.
type LabelAssignmentObjectObjectType string

// LabelInfo Metadata for a label.
type LabelInfo struct {
	// Id The unique identifier of the label.
	Id string `json:"id"`

	// Name The name of the label.
	Name string `json:"name"`
}

// LabelList Paged list of labels.
type LabelList struct {
	Labels *[]LabelListItem `json:"labels,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results.
	PageToken *string `json:"pageToken,omitempty"`

	// RowCount Total number of labels in the result set.
	RowCount *int `json:"rowCount,omitempty"`
}

// LabelListItem Label metadata.
type LabelListItem struct {
	// Color The color of the label.
	Color LabelListItemColor `json:"color"`

	// CreateTime The time when the label was created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// Id The unique identifier of the label.
	Id string `json:"id"`

	// Name The name of the label.
	Name string `json:"name"`

	// Type The type of the label (custom or preset).
	Type *LabelListItemType `json:"type,omitempty"`

	// UpdateTime The time when the label was last updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
}

// LabelListItemColor The color of the label.
type LabelListItemColor string

// LabelListItemType The type of the label (custom or preset).
type LabelListItemType string

// Limit To limit the number of results based on ranking. See [Limit by top/bottom](https://help.doit.com/docs/cloud-analytics/reports/editing-your-cloud-report#limit-by-topbottom).
type Limit struct {
	// Metric Metric selector used in reports and filters.
	Metric *ExternalMetric `json:"metric,omitempty"`

	// Sort Sort order for ranking results.
	Sort *LimitSort `json:"sort,omitempty"`

	// Value The number of items to show
	Value *int64 `json:"value,omitempty"`
}

// LimitSort Sort order for ranking results.
type LimitSort string

// ListItem Invoice line item.
type ListItem struct {
	Currency    *string  `json:"currency,omitempty"`
	Description *string  `json:"description,omitempty"`
	Details     *string  `json:"details,omitempty"`
	Price       *float64 `json:"price,omitempty"`
	Qty         *float64 `json:"qty,omitempty"`
	Type        *string  `json:"type,omitempty"`
}

// ListUsersResponseBody Response body for the list users endpoint.
type ListUsersResponseBody struct {
	// RowCount The number of returned records.
	RowCount *int64          `json:"rowCount,omitempty"`
	Users    *[]UserListItem `json:"users,omitempty"`
}

// MetricConfig Define how metrics are selected and filtered in reports.
type MetricConfig struct {
	// Type Identifier for metric type (e.g., basic, custom, extended).
	Type  MetricType `json:"type"`
	Value string     `json:"value"`
}

// MetricFilterText Text/operator used to filter metric values in metric filters.
type MetricFilterText string

// MetricType Identifier for metric type (e.g., basic, custom, extended).
type MetricType = string

// NewAllocationResponse Response returned after creating a new allocation.
type NewAllocationResponse struct {
	// Id ID of the new allocation.
	Id *string `json:"id,omitempty"`

	// Type Type of the new allocation.
	Type *NewAllocationResponseType `json:"type,omitempty"`
}

// NewAllocationResponseType Type of the new allocation.
type NewAllocationResponseType string

// ObjectType Generic object type identifier.
type ObjectType = string

// Organization Organization metadata returned by the API.
type Organization struct {
	// Id The unique ID of the organization
	Id *string `json:"id,omitempty"`

	// Name The name of the organization
	Name *string `json:"name,omitempty"`
}

// PlatformAPI Platform metadata used by product listing endpoints.
type PlatformAPI struct {
	DisplayName *string `json:"displayName,omitempty"`
	Id          *string `json:"id,omitempty"`
}

// ProductAPI Platform/product metadata used by product listing endpoints.
type ProductAPI struct {
	DisplayName *string `json:"displayName,omitempty"`
	Id          *string `json:"id,omitempty"`
	Platform    *string `json:"platform,omitempty"`
}

// RenewalSettings Settings that control subscription renewal behavior.
type RenewalSettings struct {
	RenewalType *string `json:"renewalType,omitempty"`
}

// Report Report metadata and the console URL.
type Report struct {
	// CreateTime The creation time of the report, in milliseconds since the epoch.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Id Report ID.
	Id *string `json:"id,omitempty"`

	// Owner Email address of the report owner.
	Owner *string `json:"owner,omitempty"`

	// ReportName The name of the report.
	ReportName *string     `json:"reportName,omitempty"`
	Type       *ReportType `json:"type,omitempty"`

	// UpdateTime The time when this report was last updated, in milliseconds since the epoch.
	UpdateTime *int64 `json:"updateTime,omitempty"`

	// UrlUI The URL of the report in DoiT console.
	UrlUI *string `json:"urlUI,omitempty"`
}

// ReportType defines model for Report.Type.
type ReportType string

// ReportList List of reports.
type ReportList struct {
	// PageToken Page token. It is used to request a specific page of the list results.
	PageToken *string   `json:"pageToken,omitempty"`
	Reports   *[]Report `json:"reports,omitempty"`

	// RowCount The number of returned records.
	RowCount *int64 `json:"rowCount,omitempty"`
}

// ResourcePermission A single user's permission entry for a resource.
type ResourcePermission struct {
	// Role The role assigned to the user, defining their level of access to the resource.
	Role *ResourcePermissionRole `json:"role,omitempty"`

	// User The email address of the user to whom the role is assigned.
	User *string `json:"user,omitempty"`
}

// ResourcePermissionRole The role assigned to the user, defining their level of access to the resource.
type ResourcePermissionRole string

// ResourcePermissionsResponse Permissions and metadata for a resource returned by the sharing API.
type ResourcePermissionsResponse struct {
	// CreateTime The time when this resource was created, in milliseconds since the epoch.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Description Resource description.
	Description *string `json:"description,omitempty"`

	// Id Resource ID.
	Id *string `json:"id,omitempty"`

	// Name Resource name.
	Name        *string               `json:"name,omitempty"`
	Permissions *[]ResourcePermission `json:"permissions,omitempty"`

	// Public Type of permissions users in the entire organization have for this resource
	Public *ResourcePermissionsResponsePublic `json:"public"`

	// UpdateTime The time when this resource was last updated, in milliseconds since the epoch.
	UpdateTime *int64 `json:"updateTime,omitempty"`
}

// ResourcePermissionsResponsePublic Type of permissions users in the entire organization have for this resource
type ResourcePermissionsResponsePublic string

// ResourceReference Reference to another resource, used when listing blockers or usages.
type ResourceReference struct {
	// Id Resource identifier
	Id *string `json:"id,omitempty"`

	// Name Resource name
	Name *string `json:"name,omitempty"`

	// Owner Resource owner (only present if requester doesn't have access)
	Owner *string `json:"owner,omitempty"`
}

// Role Definition and permissions assigned to a role.
type Role struct {
	// Customer The customer ID if this is a custom role.
	Customer *string `json:"customer,omitempty"`

	// Id The unique ID of the role.
	Id *string `json:"id,omitempty"`

	// Name The name of the role.
	Name *string `json:"name,omitempty"`

	// Permissions List of permission IDs assigned to the role.
	Permissions *[]string `json:"permissions,omitempty"`

	// Type The type of the role (preset or custom).
	Type *string `json:"type,omitempty"`
}

// RunReportResult Results returned when running a report; includes schema and rows.
type RunReportResult struct {
	Result *struct {
		// CacheHit If true, results were fetched from the cache.
		CacheHit     *bool                              `json:"cacheHit,omitempty"`
		ForecastRows *[][]Value                         `json:"forecastRows,omitempty"`
		MlFeatures   *[]RunReportResultResultMlFeatures `json:"mlFeatures,omitempty"`
		Rows         *[][]Value                         `json:"rows,omitempty"`
		Schema       *[]SchemaField                     `json:"schema,omitempty"`
	} `json:"result,omitempty"`
}

// RunReportResultResultMlFeatures defines model for RunReportResult.Result.MlFeatures.
type RunReportResultResultMlFeatures string

// SchemaField Schema of a report result column.
type SchemaField struct {
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
}

// Seats Licensing seat counts for a subscription or asset.
type Seats struct {
	LicensedNumberOfSeats *int64 `json:"licensedNumberOfSeats,omitempty"`
	MaximumNumberOfSeats  *int64 `json:"maximumNumberOfSeats,omitempty"`
	NumberOfSeats         *int64 `json:"numberOfSeats,omitempty"`
}

// SlackChannel Information of a Slack channel for notifications.
type SlackChannel struct {
	CustomerId *string `json:"customerId,omitempty"`
	Id         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
	Shared     *bool   `json:"shared,omitempty"`
	Type       *string `json:"type,omitempty"`
	Workspace  *string `json:"workspace,omitempty"`
}

// Subscription Subscription-related metadata for an asset.
type Subscription struct {
	BillingMethod *string `json:"billingMethod,omitempty"`
	CreationTime  *int64  `json:"creationTime,omitempty"`
	Id            *string `json:"id,omitempty"`

	// Plan Subscription-related metadata for an asset.
	Plan            *SubscriptionPlan `json:"plan,omitempty"`
	PurchaseOrderID *string           `json:"purchaseOrderID,omitempty"`

	// RenewalSettings Settings that control subscription renewal behavior.
	RenewalSettings *RenewalSettings `json:"renewalSettings,omitempty"`
	ResourceUIURL   *string          `json:"resourceUIURL,omitempty"`

	// Seats Licensing seat counts for a subscription or asset.
	Seats   *Seats  `json:"seats,omitempty"`
	SkuID   *string `json:"skuID,omitempty"`
	SkuName *string `json:"skuName,omitempty"`
	Status  *string `json:"status,omitempty"`
}

// SubscriptionPlan Subscription-related metadata for an asset.
type SubscriptionPlan struct {
	// CommitmentInterval Subscription-related metadata for an asset.
	CommitmentInterval *SubscriptionPlanCommitmentInterval `json:"commitmentInterval,omitempty"`
	IsCommitmentPlan   *bool                               `json:"isCommitmentPlan,omitempty"`
	PlanName           *string                             `json:"planName,omitempty"`
}

// SubscriptionPlanCommitmentInterval Subscription-related metadata for an asset.
type SubscriptionPlanCommitmentInterval struct {
	EndTime   *int64 `json:"endTime,omitempty"`
	StartTime *int64 `json:"startTime,omitempty"`
}

// TicketCreateFormExtAPI Wrapper object for creating support tickets via the external API.
type TicketCreateFormExtAPI struct {
	// Ticket Payload to create a support ticket via API.
	Ticket TicketExtAPI `json:"ticket"`
}

// TicketExtAPI Payload to create a support ticket via API.
type TicketExtAPI struct {
	// Body The body of the ticket (can include html formatting).
	Body string `json:"body"`

	// Created Ticket creation time.
	Created *string `json:"created,omitempty"`

	// Platform Platform of the ticket.
	Platform TicketExtAPIPlatform `json:"platform"`

	// Product Ticket product details.
	Product string `json:"product"`

	// Severity Ticket severity.
	Severity TicketExtAPISeverity `json:"severity"`

	// Subject The subject of the ticket.
	Subject string `json:"subject"`
}

// TicketExtAPIPlatform Platform of the ticket.
type TicketExtAPIPlatform string

// TicketExtAPISeverity Ticket severity.
type TicketExtAPISeverity string

// TicketListItem Summary information about a support ticket.
type TicketListItem struct {
	// CreateTime The time when this ticket was created, in milliseconds since the epoch.
	CreateTime *int64 `json:"createTime,omitempty"`

	// Id Ticket ID (e.g., "33234").
	Id *int64 `json:"id,omitempty"`

	// IsPublic Whether the ticket is public.
	IsPublic *bool `json:"is_public,omitempty"`

	// Platform Platform of the ticket.
	Platform *TicketListItemPlatform `json:"platform,omitempty"`

	// Product Ticket product.
	Product *string `json:"product,omitempty"`

	// Requester The ticket requester in the form of user@domain.com
	Requester *string `json:"requester,omitempty"`

	// Severity Ticket severity.
	Severity *string `json:"severity,omitempty"`

	// Status Ticket status.
	Status *string `json:"status,omitempty"`

	// Subject The subject of the ticket.
	Subject *string `json:"subject,omitempty"`

	// UpdateTime The time when this ticket was last updated, in milliseconds since the epoch.
	UpdateTime *int64 `json:"updateTime,omitempty"`

	// UrlUI Link to the report in DoiT console.
	UrlUI *string `json:"urlUI,omitempty"`
}

// TicketListItemPlatform Platform of the ticket.
type TicketListItemPlatform string

// TicketResponseExtAPI Response returned after creating a ticket.
type TicketResponseExtAPI struct {
	// Created Ticket creation time.
	Created *int64 `json:"created,omitempty"`

	// Id Ticket ID.
	Id *int64 `json:"id,omitempty"`

	// Platform Ticket platform.
	Platform *TicketResponseExtAPIPlatform `json:"platform,omitempty"`

	// Product Ticket product.
	Product *string `json:"product,omitempty"`

	// Requester Email address of the requester.
	Requester *string `json:"requester,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketResponseExtAPISeverity `json:"severity,omitempty"`

	// Status Ticket status.
	Status *string `json:"status,omitempty"`

	// Subject Ticket subject.
	Subject *string `json:"subject,omitempty"`

	// UrlUI URL to access the ticket in DoiT console.
	UrlUI *string `json:"urlUI,omitempty"`
}

// TicketResponseExtAPIPlatform Ticket platform.
type TicketResponseExtAPIPlatform string

// TicketResponseExtAPISeverity Severity of the ticket.
type TicketResponseExtAPISeverity string

// TicketsList List of support tickets.
type TicketsList struct {
	// PageToken Page token, returned by a previous call, to request the next page of results.
	PageToken *string `json:"pageToken,omitempty"`

	// RowCount Tickets rows count
	RowCount *int64            `json:"rowCount,omitempty"`
	Tickets  *[]TicketListItem `json:"tickets,omitempty"`
}

// TimeSettings Specify a predefined or custom time range for the report.
// For example, to specify a custom time range of "last 2 days", set the mode to `last`, the amount to `2`, and the unit to `day`. If `includeCurrent` is `true`, the range will be yesterday and today; otherwise, the range will be yesterday and the day before yesterday.
// If "custom" type is specified, you need to provide a custom time range in the `customTimeRange` field.
type TimeSettings struct {
	// Amount Number of time units to include in the time range.
	Amount *int64 `json:"amount,omitempty"`

	// IncludeCurrent Whether to include the current time period.
	IncludeCurrent *bool `json:"includeCurrent,omitempty"`

	// Mode Time range mode (last N periods, current period, or custom).
	Mode *TimeSettingsMode `json:"mode,omitempty"`

	// Unit Time unit for the time range.
	Unit *TimeSettingsUnit `json:"unit,omitempty"`
}

// TimeSettingsMode Time range mode (last N periods, current period, or custom).
type TimeSettingsMode string

// TimeSettingsUnit Time unit for the time range.
type TimeSettingsUnit string

// UpdateAllocationRequest Request body for updating an allocation.
type UpdateAllocationRequest struct {
	// Description Allocation description
	Description *string `json:"description"`

	// Name Allocation name
	Name *string `json:"name"`

	// Rule Single allocation rule.
	Rule  *AllocationRule        `json:"rule"`
	Rules *[]GroupAllocationRule `json:"rules,omitempty"`

	// UnallocatedCosts Custom label for values that do not fit into allocation (required for group type allocation).
	UnallocatedCosts *string `json:"unallocatedCosts"`
}

// UpdateAnnotationRequest Request body for updating an annotation.
type UpdateAnnotationRequest struct {
	// Content The content of the annotation.
	Content *string `json:"content"`

	// Labels List of label IDs to associate with the annotation. Labels must already exist.
	Labels *[]string `json:"labels"`

	// Reports List of report IDs associated with the annotation.
	Reports *[]string `json:"reports"`

	// Timestamp The date associated with the annotation.
	Timestamp *time.Time `json:"timestamp"`
}

// UpdateLabelRequest Request body for updating a label.
type UpdateLabelRequest struct {
	// Color The color of the label.
	Color *UpdateLabelRequestColor `json:"color"`

	// Name The name of the label.
	Name *string `json:"name"`
}

// UpdateLabelRequestColor The color of the label.
type UpdateLabelRequestColor string

// UpdateUserRequest Fields allowed when updating an existing user.
type UpdateUserRequest struct {
	// FirstName The user's first name.
	FirstName *string `json:"firstName,omitempty"`

	// JobFunction The user's job function.
	JobFunction *UpdateUserRequestJobFunction `json:"jobFunction,omitempty"`

	// Language The user's preferred language.
	Language *UpdateUserRequestLanguage `json:"language,omitempty"`

	// LastName The user's last name.
	LastName *string `json:"lastName,omitempty"`

	// Phone The user's country code (e.g., +44).
	Phone *string `json:"phone,omitempty"`

	// PhoneExtension The user's phone extension (8-15 digits).
	PhoneExtension *string `json:"phoneExtension,omitempty"`

	// RoleId The ID of the role to assign to the user.
	RoleId *string `json:"roleId,omitempty"`
}

// UpdateUserRequestJobFunction The user's job function.
type UpdateUserRequestJobFunction string

// UpdateUserRequestLanguage The user's preferred language.
type UpdateUserRequestLanguage string

// UpdateUserResponse Response of a user update operation.
type UpdateUserResponse struct {
	// Message Success message
	Message *string `json:"message,omitempty"`

	// User The updated user record.
	User *UpdatedUserBody `json:"user,omitempty"`
}

// UpdatedUserBody The updated user record.
type UpdatedUserBody struct {
	// DisplayName The user's display name.
	DisplayName *string `json:"displayName,omitempty"`

	// Email The user's email address.
	Email *string `json:"email,omitempty"`

	// FirstName The user's first name.
	FirstName *string `json:"firstName,omitempty"`

	// Id The unique ID of the user.
	Id *string `json:"id,omitempty"`

	// JobFunction The user's job function.
	JobFunction *UpdatedUserBodyJobFunction `json:"jobFunction,omitempty"`

	// Language The user's preferred language.
	Language *UpdatedUserBodyLanguage `json:"language,omitempty"`

	// LastName The user's last name.
	LastName *string `json:"lastName,omitempty"`

	// OrganizationId The ID of the user's organization.
	OrganizationId *string `json:"organizationId,omitempty"`

	// Phone The user's country code (e.g., +44).
	Phone *string `json:"phone,omitempty"`

	// PhoneExtension The user's phone extension.
	PhoneExtension *string `json:"phoneExtension,omitempty"`

	// RoleId The ID of the user's role.
	RoleId *string `json:"roleId,omitempty"`
}

// UpdatedUserBodyJobFunction The user's job function.
type UpdatedUserBodyJobFunction string

// UpdatedUserBodyLanguage The user's preferred language.
type UpdatedUserBodyLanguage string

// UserListItem Summary information of a user.
type UserListItem struct {
	// DisplayName The user's display name.
	DisplayName *string `json:"displayName,omitempty"`

	// Email The email address of the user.
	Email *string `json:"email,omitempty"`

	// FirstName The user's first name.
	FirstName *string `json:"firstName,omitempty"`

	// Id The unique ID of the user.
	Id *string `json:"id,omitempty"`

	// JobFunction The user's job function.
	JobFunction *UserListItemJobFunction `json:"jobFunction,omitempty"`

	// Language The user's preferred language.
	Language *UserListItemLanguage `json:"language,omitempty"`

	// LastName The user's last name.
	LastName *string `json:"lastName,omitempty"`

	// OrganizationId The ID of the user's organization.
	OrganizationId *string `json:"organizationId,omitempty"`

	// Phone The user's country code (e.g., +44).
	Phone *string `json:"phone,omitempty"`

	// PhoneExtension The user's phone extension.
	PhoneExtension *string `json:"phoneExtension,omitempty"`

	// RoleId The ID of the user's role.
	RoleId *string `json:"roleId,omitempty"`

	// Status The status of the user (active or invited).
	Status *UserListItemStatus `json:"status,omitempty"`
}

// UserListItemJobFunction The user's job function.
type UserListItemJobFunction string

// UserListItemLanguage The user's preferred language.
type UserListItemLanguage string

// UserListItemStatus The status of the user (active or invited).
type UserListItemStatus string

// ValidateResponse A response confirming caller's domain and email.
type ValidateResponse struct {
	Domain *string `json:"domain,omitempty"`
	Email  *string `json:"email,omitempty"`
}

// Value The content of a single cell from a BigQuery result.
type Value = map[string]interface{}

// MaxResults defines model for maxResults.
type MaxResults = string

// PageToken defines model for pageToken.
type PageToken = string

// ReportId defines model for reportId.
type ReportId = string

// ResourceId defines model for resourceId.
type ResourceId = string

// ResourceType defines model for resourceType.
type ResourceType string

// SortOrder defines model for sortOrder.
type SortOrder string

// N400 Standard error response structure.
type N400 = Error

// N401 Standard error response structure.
type N401 = Error

// N403 Standard error response structure.
type N403 = Error

// N404 Standard error response structure.
type N404 = Error

// N429 Standard error response structure.
type N429 = Error

// N500 Standard error response structure.
type N500 = Error

// ListAlertsParams defines parameters for ListAlerts.
type ListAlertsParams struct {
	// SortBy A field by which the results will be sorted.
	SortBy *ListAlertsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListAlertsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results. The syntax is `key:[<value>]`. Multiple filters can be connected using a pipe |. See [Filters](https://developer.doit.com/docs/filters).
	// Available filter keys: **owner**, **name**
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListAlertsParamsSortBy defines parameters for ListAlerts.
type ListAlertsParamsSortBy string

// ListAlertsParamsSortOrder defines parameters for ListAlerts.
type ListAlertsParamsSortOrder string

// ListAllocationsParams defines parameters for ListAllocations.
type ListAllocationsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results.
	// Valid fields: **type**, **owner**, **name**.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy A field by which the results will be sorted.
	SortBy *ListAllocationsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListAllocationsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListAllocationsParamsSortBy defines parameters for ListAllocations.
type ListAllocationsParamsSortBy string

// ListAllocationsParamsSortOrder defines parameters for ListAllocations.
type ListAllocationsParamsSortOrder string

// ListAnnotationsParams defines parameters for ListAnnotations.
type ListAnnotationsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results.
	// Valid fields: **content**, **timestamp**, **labels**.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy A field by which the results will be sorted.
	SortBy *ListAnnotationsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListAnnotationsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListAnnotationsParamsSortBy defines parameters for ListAnnotations.
type ListAnnotationsParamsSortBy string

// ListAnnotationsParamsSortOrder defines parameters for ListAnnotations.
type ListAnnotationsParamsSortOrder string

// ListAttributionGroupsParams defines parameters for ListAttributionGroups.
type ListAttributionGroupsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// SortBy A field by which the results will be sorted.
	SortBy *ListAttributionGroupsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListAttributionGroupsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListAttributionGroupsParamsSortBy defines parameters for ListAttributionGroups.
type ListAttributionGroupsParamsSortBy string

// ListAttributionGroupsParamsSortOrder defines parameters for ListAttributionGroups.
type ListAttributionGroupsParamsSortOrder string

// ListAttributionsParams defines parameters for ListAttributions.
type ListAttributionsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results.
	// Valid fields: **type**, **owner**, **name**.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The field by which the results are sorted.
	SortBy *ListAttributionsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListAttributionsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListAttributionsParamsSortBy defines parameters for ListAttributions.
type ListAttributionsParamsSortBy string

// ListAttributionsParamsSortOrder defines parameters for ListAttributions.
type ListAttributionsParamsSortOrder string

// CreateAttributionJSONBody defines parameters for CreateAttribution.
type CreateAttributionJSONBody struct {
	// Components List of Attribution filters
	Components []AttributionComponent `json:"components"`

	// Description Description of the attribution
	Description *string `json:"description,omitempty"`

	// Formula Attribution formula (A is the first component, B is the second one, and so on.)
	Formula *string `json:"formula,omitempty"`

	// Name Name of the attribution
	Name string `json:"name"`
}

// UpdateAttributionJSONBody defines parameters for UpdateAttribution.
type UpdateAttributionJSONBody struct {
	// Components List of Attribution filters
	Components *[]AttributionComponent `json:"components,omitempty"`

	// Description Description of the attribution
	Description *string `json:"description,omitempty"`

	// Formula Attribution formula (A is the first component, B is the second one, C is the third, and so on.)
	Formula *string `json:"formula,omitempty"`

	// Name Attribution Name
	Name *string `json:"name,omitempty"`
}

// ListBudgetsParams defines parameters for ListBudgets.
type ListBudgetsParams struct {
	// MaxResults The maximum number of results to return in a single page. Leverage the page tokens to iterate through the entire collection.
	MaxResults *string `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results of the request. The syntax is "key:[<value>]".
	// Available keys: owner, lastModified in ms (>lasModified). Multiple filters can be connected using a pipe |. Note that using different keys in the same filter results in "AND," while using the same key multiple times in the same filter results in "OR".
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// MinCreationTime Min value for reports creation time, in milliseconds since the POSIX epoch. If set, only reports created after or at this timestamp are returned.
	MinCreationTime *string `form:"minCreationTime,omitempty" json:"minCreationTime,omitempty"`

	// MaxCreationTime Max value for reports creation time, in milliseconds since the POSIX epoch. If set, only reports created before or at this timestamp are returned.
	MaxCreationTime *string `form:"maxCreationTime,omitempty" json:"maxCreationTime,omitempty"`
}

// ListCommitmentsParams defines parameters for ListCommitments.
type ListCommitmentsParams struct {
	// SortBy A field by which the results will be sorted.
	SortBy *ListCommitmentsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListCommitmentsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results. The syntax is `key:[<value>]`. Multiple filters can be connected using a pipe |. See [Filters](https://developer.doit.com/docs/filters).
	// Available filter keys: **name**, **provider**
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListCommitmentsParamsSortBy defines parameters for ListCommitments.
type ListCommitmentsParamsSortBy string

// ListCommitmentsParamsSortOrder defines parameters for ListCommitments.
type ListCommitmentsParamsSortOrder string

// GetDimensionsParams defines parameters for GetDimensions.
type GetDimensionsParams struct {
	// Type Dimension type
	Type DimensionsTypes `form:"type" json:"type"`

	// Id Dimension id
	Id string `form:"id" json:"id"`
}

// ListDimensionsParams defines parameters for ListDimensions.
type ListDimensionsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results.
	// The fields eligible for filtering are: type, label, key.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy A field by which the results will be sorted.
	SortBy *ListDimensionsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListDimensionsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListDimensionsParamsSortBy defines parameters for ListDimensions.
type ListDimensionsParamsSortBy string

// ListDimensionsParamsSortOrder defines parameters for ListDimensions.
type ListDimensionsParamsSortOrder string

// ListLabelsParams defines parameters for ListLabels.
type ListLabelsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results.
	// Valid fields: **name**, **type**.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy A field by which the results will be sorted.
	SortBy *ListLabelsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order can be ascending or descending.
	SortOrder *ListLabelsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListLabelsParamsSortBy defines parameters for ListLabels.
type ListLabelsParamsSortBy string

// ListLabelsParamsSortOrder defines parameters for ListLabels.
type ListLabelsParamsSortOrder string

// ListReportsParams defines parameters for ListReports.
type ListReportsParams struct {
	// MaxResults The maximum number of results to return in a single page. Use the page tokens to iterate through the entire collection.
	MaxResults *MaxResults `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results.
	// The syntax is `key:[<value>]`. Multiple filters can be connected using a pipe |. See [Filters](https://developer.doit.com/docs/filters).
	// Possible filter keys: **reportName**, **owner**, **type**, **updateTime**
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// MinCreationTime Min value for reports creation time, in milliseconds since the POSIX epoch. If set, only reports created after or at this timestamp are returned.
	MinCreationTime *string `form:"minCreationTime,omitempty" json:"minCreationTime,omitempty"`

	// MaxCreationTime Max value for reports creation time, in milliseconds since the POSIX epoch. If set, only reports created before or at this timestamp are returned.
	MaxCreationTime *string `form:"maxCreationTime,omitempty" json:"maxCreationTime,omitempty"`
}

// CreateReportJSONBody defines parameters for CreateReport.
type CreateReportJSONBody struct {
	// Config Report configuration.
	Config *ExternalConfig `json:"config,omitempty"`

	// Description Report description.
	Description *string `json:"description,omitempty"`

	// Name Report name.
	Name *string `json:"name,omitempty"`
}

// QueryJSONBody defines parameters for Query.
type QueryJSONBody struct {
	// Config Report configuration.
	Config *ExternalConfig `json:"config,omitempty"`
}

// GetReportParams defines parameters for GetReport.
type GetReportParams struct {
	// TimeRange An optional parameter to override the report time settings. Value should be represented in the format P[n]Y[n]M[n]D[n]. In the representations, the [n] is replaced by the value for each of the date and time elements that follow the [n].
	TimeRange *string `form:"timeRange,omitempty" json:"timeRange,omitempty"`

	// StartDate An optional parameter to override the report time settings. Must be provided together with `endDate`. Format: yyyy-mm-dd
	StartDate *string `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate An optional parameter to override the report time settings. Must be provided together with `startDate`. Format: yyyy-mm-dd
	EndDate *string `form:"endDate,omitempty" json:"endDate,omitempty"`
}

// ListAnomaliesParams defines parameters for ListAnomalies.
type ListAnomaliesParams struct {
	// MinCreationTime Min value for the anomaly detection time
	MinCreationTime *string `form:"minCreationTime,omitempty" json:"minCreationTime,omitempty"`

	// MaxCreationTime Max value for the anomaly detection time
	MaxCreationTime *string `form:"maxCreationTime,omitempty" json:"maxCreationTime,omitempty"`

	// Filter An expression for filtering the results of the request
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// MaxResults The maximum number of results to return in a single page
	MaxResults *int64 `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// IdOfAssetsParams defines parameters for IdOfAssets.
type IdOfAssetsParams struct {
	// MaxResults The maximum number of results to return in a single page. Leverage the page tokens to iterate through the entire collection.
	MaxResults *int64 `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results of the request. The syntax
	// is `key:[<value>]`. e.g: "type:g-suite". Multiple filters can be
	// connected using a pipe |. Note that using different keys in the same
	// filter results in AND, while using the same key multiple times in
	// the same filter results in OR.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// IdOfAssetJSONBody defines parameters for IdOfAsset.
type IdOfAssetJSONBody struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

// CreateAssetParams defines parameters for CreateAsset.
type CreateAssetParams struct {
	// Type Asset type. For example, amazon-web-services
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Mode Asset mode.
	Mode *string `form:"mode,omitempty" json:"mode,omitempty"`

	// AccountName The desired name of the account.
	AccountName *string `form:"accountName,omitempty" json:"accountName,omitempty"`

	// RootEmail The root account email.
	RootEmail *string `form:"rootEmail,omitempty" json:"rootEmail,omitempty"`
}

// ListInvoicesParams defines parameters for ListInvoices.
type ListInvoicesParams struct {
	// MaxResults The maximum number of results to return in a single page. Leverage the page tokens to iterate through the entire collection.
	MaxResults *int64 `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	Filter    *Filter    `form:"filter,omitempty" json:"filter,omitempty"`

	// MinCreationTime Min value for the invoice creation time, in milliseconds since the POSIX epoch. If set, only invoices created after or at this timestamp are returned.
	MinCreationTime *int64 `form:"minCreationTime,omitempty" json:"minCreationTime,omitempty"`

	// MaxCreationTime Max value for the invoice creation time, in milliseconds since the POSIX epoch. If set, only invoices created before or at this timestamp are returned.
	MaxCreationTime *int64 `form:"maxCreationTime,omitempty" json:"maxCreationTime,omitempty"`
}

// ListKnownIssuesParams defines parameters for ListKnownIssues.
type ListKnownIssuesParams struct {
	// MaxResults The maximum number of results to return in a single page. Leverage the page tokens to iterate through the entire collection.
	MaxResults *int64 `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results. The syntax is `key:[<value>]`. Multiple filters can be connected using a pipe |. See [Filters](https://developer.doit.com/docs/filters).
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// MinCreationTime Min value for the cloud incident creation time, in milliseconds since the POSIX epoch. If set, only cloud incidents created after or at this timestamp are returned.
	MinCreationTime *string `form:"minCreationTime,omitempty" json:"minCreationTime,omitempty"`

	// MaxCreationTime Max value for the cloud incident creation time, in milliseconds since the POSIX epoch. If set, only cloud incidents created before or at this
	// timestamp are returned.
	MaxCreationTime *string `form:"maxCreationTime,omitempty" json:"maxCreationTime,omitempty"`
}

// DatahubEventsCSVFileMultipartBody defines parameters for DatahubEventsCSVFile.
type DatahubEventsCSVFileMultipartBody struct {
	// File The CSV file to upload, either uncompressed or compressed in ZIP or GZ format. The maximum file size is 30 MB.
	File *openapi_types.File `json:"file,omitempty"`

	// Provider The identifier of the data provider. Allowed characters: alphanumeric (0-9,a-z,A-Z), underscore (_), space, dash (-).
	Provider *string `json:"provider,omitempty"`
}

// DatahubEventsJSONBody defines parameters for DatahubEvents.
type DatahubEventsJSONBody struct {
	Events *[]struct {
		Dimensions *[]struct {
			// Key If the type is `fixed`, the key must be a valid fixed value. See the [DataHub API Guide](https://developer.doit.com/docs/datahub-api) for more information.
			Key *string `json:"key,omitempty"`

			// Type The dimension type.
			Type  *DatahubEventsJSONBodyEventsDimensionsType     `json:"type,omitempty"`
			Value *DatahubEventsJSONBody_Events_Dimensions_Value `json:"value,omitempty"`
		} `json:"dimensions,omitempty"`

		// Id The event id. Must be unique within the dataset. If not set, a UUIDv4 will be generated at ingestion time.
		Id      *string `json:"id,omitempty"`
		Metrics *[]struct {
			// Type The type of the metric. If you choose "cost" or "usage", it will map to the basic "Cost" or "Usage" metric in Cloud Analytics reports. You can also use this field to define custom metric types, such as "working_hours", "ride", etc.
			Type *string `json:"type,omitempty"`

			// Value The value of the metric.
			Value *float64 `json:"value,omitempty"`
		} `json:"metrics,omitempty"`

		// Provider The identifier of the data provider. Allowed characters: alphanumeric (0-9,a-z,A-Z), underscore (_), space, dash (-).
		Provider string `json:"provider"`

		// Time The timestamp of the event in RFC3339 format.
		Time time.Time `json:"time"`
	} `json:"events,omitempty"`
}

// DatahubEventsJSONBodyEventsDimensionsType defines parameters for DatahubEvents.
type DatahubEventsJSONBodyEventsDimensionsType string

// DatahubEventsJSONBodyEventsDimensionsValue0 defines parameters for DatahubEvents.
type DatahubEventsJSONBodyEventsDimensionsValue0 = string

// DatahubEventsJSONBodyEventsDimensionsValue1 defines parameters for DatahubEvents.
type DatahubEventsJSONBodyEventsDimensionsValue1 = bool

// DatahubEventsJSONBody_Events_Dimensions_Value defines parameters for DatahubEvents.
type DatahubEventsJSONBody_Events_Dimensions_Value struct {
	union json.RawMessage
}

// DeleteDatahubEventsByFilterJSONBody defines parameters for DeleteDatahubEventsByFilter.
type DeleteDatahubEventsByFilterJSONBody struct {
	// Dataset The dataset (provider) of the events to be deleted.
	Dataset string `json:"dataset"`

	// EndTime The end timestamp of the time range in RFC3339 format.
	EndTime  *time.Time `json:"endTime,omitempty"`
	EventIds *[]string  `json:"eventIds,omitempty"`

	// StartTime The start timestamp of the time range in RFC3339 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// GetResourcePermissionParamsResourceType defines parameters for GetResourcePermission.
type GetResourcePermissionParamsResourceType string

// UpdateResourcePermissionJSONBody defines parameters for UpdateResourcePermission.
type UpdateResourcePermissionJSONBody struct {
	Permissions *[]ResourcePermission `json:"permissions,omitempty"`

	// Public The type of permissions granted to all users in the organization for this resource.
	Public *UpdateResourcePermissionJSONBodyPublic `json:"public"`
}

// UpdateResourcePermissionParamsResourceType defines parameters for UpdateResourcePermission.
type UpdateResourcePermissionParamsResourceType string

// UpdateResourcePermissionJSONBodyPublic defines parameters for UpdateResourcePermission.
type UpdateResourcePermissionJSONBodyPublic string

// ListProductsParams defines parameters for ListProducts.
type ListProductsParams struct {
	Platform *string `form:"platform,omitempty" json:"platform,omitempty"`
}

// IdOfTicketsParams defines parameters for IdOfTickets.
type IdOfTicketsParams struct {
	// MaxResults The maximum number of results to return in a single page. Leverage the page tokens to iterate through the entire collection.
	MaxResults *int64 `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// PageToken Page token, returned by a previous call, to request the next page of results
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter An expression for filtering the results of the request. The syntax is `key:[<value>]`. e.g: "severity:normal". Multiple filters can be
	// connected using a pipe |. Note that using different keys in the same
	// filter results in AND, while using the same key multiple times in
	// the same filter results in OR.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// MinCreationTime Min value for tickets creation time, in milliseconds since the POSIX epoch. If set, only tickets created after or at this timestamp are returned.
	MinCreationTime *string `form:"minCreationTime,omitempty" json:"minCreationTime,omitempty"`

	// MaxCreationTime Max value for tickets creation time, in milliseconds since the POSIX epoch. If set, only tickets created before or at this timestamp are returned.
	MaxCreationTime *string `form:"maxCreationTime,omitempty" json:"maxCreationTime,omitempty"`
}

// CreateAlertJSONRequestBody defines body for CreateAlert for application/json ContentType.
type CreateAlertJSONRequestBody = AlertRequest

// UpdateAlertJSONRequestBody defines body for UpdateAlert for application/json ContentType.
type UpdateAlertJSONRequestBody = AlertUpdateRequest

// CreateAllocationJSONRequestBody defines body for CreateAllocation for application/json ContentType.
type CreateAllocationJSONRequestBody = CreateAllocationRequest

// UpdateAllocationJSONRequestBody defines body for UpdateAllocation for application/json ContentType.
type UpdateAllocationJSONRequestBody = UpdateAllocationRequest

// CreateAnnotationJSONRequestBody defines body for CreateAnnotation for application/json ContentType.
type CreateAnnotationJSONRequestBody = CreateAnnotationRequest

// UpdateAnnotationJSONRequestBody defines body for UpdateAnnotation for application/json ContentType.
type UpdateAnnotationJSONRequestBody = UpdateAnnotationRequest

// CreateAttributionGroupJSONRequestBody defines body for CreateAttributionGroup for application/json ContentType.
type CreateAttributionGroupJSONRequestBody = AttributionGroupRequest

// UpdateAttributionGroupJSONRequestBody defines body for UpdateAttributionGroup for application/json ContentType.
type UpdateAttributionGroupJSONRequestBody = AttributionGroupUpdateRequest

// CreateAttributionJSONRequestBody defines body for CreateAttribution for application/json ContentType.
type CreateAttributionJSONRequestBody CreateAttributionJSONBody

// UpdateAttributionJSONRequestBody defines body for UpdateAttribution for application/json ContentType.
type UpdateAttributionJSONRequestBody UpdateAttributionJSONBody

// CreateBudgetJSONRequestBody defines body for CreateBudget for application/json ContentType.
type CreateBudgetJSONRequestBody = BudgetCreateUpdateRequest

// UpdateBudgetJSONRequestBody defines body for UpdateBudget for application/json ContentType.
type UpdateBudgetJSONRequestBody = BudgetCreateUpdateRequest

// CreateLabelJSONRequestBody defines body for CreateLabel for application/json ContentType.
type CreateLabelJSONRequestBody = CreateLabelRequest

// UpdateLabelJSONRequestBody defines body for UpdateLabel for application/json ContentType.
type UpdateLabelJSONRequestBody = UpdateLabelRequest

// AssignObjectsToLabelJSONRequestBody defines body for AssignObjectsToLabel for application/json ContentType.
type AssignObjectsToLabelJSONRequestBody = AssignObjectsToLabelRequest

// CreateReportJSONRequestBody defines body for CreateReport for application/json ContentType.
type CreateReportJSONRequestBody CreateReportJSONBody

// QueryJSONRequestBody defines body for Query for application/json ContentType.
type QueryJSONRequestBody QueryJSONBody

// UpdateReportJSONRequestBody defines body for UpdateReport for application/json ContentType.
type UpdateReportJSONRequestBody = ExternalUpdateReport

// IdOfAssetJSONRequestBody defines body for IdOfAsset for application/json ContentType.
type IdOfAssetJSONRequestBody IdOfAssetJSONBody

// FindCloudDiagramsJSONRequestBody defines body for FindCloudDiagrams for application/json ContentType.
type FindCloudDiagramsJSONRequestBody = FindCloudDiagramsRequest

// DatahubEventsCSVFileMultipartRequestBody defines body for DatahubEventsCSVFile for multipart/form-data ContentType.
type DatahubEventsCSVFileMultipartRequestBody DatahubEventsCSVFileMultipartBody

// DatahubEventsJSONRequestBody defines body for DatahubEvents for application/json ContentType.
type DatahubEventsJSONRequestBody DatahubEventsJSONBody

// DeleteDatahubEventsByFilterJSONRequestBody defines body for DeleteDatahubEventsByFilter for application/json ContentType.
type DeleteDatahubEventsByFilterJSONRequestBody DeleteDatahubEventsByFilterJSONBody

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody = InviteUserRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserRequest

// UpdateResourcePermissionJSONRequestBody defines body for UpdateResourcePermission for application/json ContentType.
type UpdateResourcePermissionJSONRequestBody UpdateResourcePermissionJSONBody

// IdOfTicketsPostJSONRequestBody defines body for IdOfTicketsPost for application/json ContentType.
type IdOfTicketsPostJSONRequestBody = TicketCreateFormExtAPI

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAlerts request
	ListAlerts(ctx context.Context, params *ListAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAlertWithBody request with any body
	CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlert request
	DeleteAlert(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlert request
	GetAlert(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAlertWithBody request with any body
	UpdateAlertWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAlert(ctx context.Context, id string, body UpdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllocations request
	ListAllocations(ctx context.Context, params *ListAllocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAllocationWithBody request with any body
	CreateAllocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAllocation(ctx context.Context, body CreateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllocation request
	DeleteAllocation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllocation request
	GetAllocation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAllocationWithBody request with any body
	UpdateAllocationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAllocation(ctx context.Context, id string, body UpdateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAnnotations request
	ListAnnotations(ctx context.Context, params *ListAnnotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAnnotationWithBody request with any body
	CreateAnnotationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAnnotation(ctx context.Context, body CreateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAnnotation request
	DeleteAnnotation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnnotation request
	GetAnnotation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAnnotationWithBody request with any body
	UpdateAnnotationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAnnotation(ctx context.Context, id string, body UpdateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttributionGroups request
	ListAttributionGroups(ctx context.Context, params *ListAttributionGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAttributionGroupWithBody request with any body
	CreateAttributionGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAttributionGroup(ctx context.Context, body CreateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttributionGroup request
	DeleteAttributionGroup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttributionGroup request
	GetAttributionGroup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttributionGroupWithBody request with any body
	UpdateAttributionGroupWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttributionGroup(ctx context.Context, id string, body UpdateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttributions request
	ListAttributions(ctx context.Context, params *ListAttributionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAttributionWithBody request with any body
	CreateAttributionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAttribution(ctx context.Context, body CreateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttribution request
	DeleteAttribution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttribution request
	GetAttribution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttributionWithBody request with any body
	UpdateAttributionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttribution(ctx context.Context, id string, body UpdateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBudgets request
	ListBudgets(ctx context.Context, params *ListBudgetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBudgetWithBody request with any body
	CreateBudgetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBudget(ctx context.Context, body CreateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBudget request
	DeleteBudget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudget request
	GetBudget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBudgetWithBody request with any body
	UpdateBudgetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBudget(ctx context.Context, id string, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommitments request
	ListCommitments(ctx context.Context, params *ListCommitmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommitment request
	GetCommitment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDimensions request
	GetDimensions(ctx context.Context, params *GetDimensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDimensions request
	ListDimensions(ctx context.Context, params *ListDimensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLabels request
	ListLabels(ctx context.Context, params *ListLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLabelWithBody request with any body
	CreateLabelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLabel(ctx context.Context, body CreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLabel request
	DeleteLabel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabel request
	GetLabel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLabelWithBody request with any body
	UpdateLabelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLabel(ctx context.Context, id string, body UpdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignObjectsToLabelWithBody request with any body
	AssignObjectsToLabelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignObjectsToLabel(ctx context.Context, id string, body AssignObjectsToLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReports request
	ListReports(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReportWithBody request with any body
	CreateReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReport(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryWithBody request with any body
	QueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Query(ctx context.Context, body QueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReport request
	DeleteReport(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReport request
	GetReport(ctx context.Context, id ReportId, params *GetReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateReportWithBody request with any body
	UpdateReportWithBody(ctx context.Context, id ReportId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateReport(ctx context.Context, id ReportId, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportConfig request
	GetReportConfig(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAnomalies request
	ListAnomalies(ctx context.Context, params *ListAnomaliesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnomaly request
	GetAnomaly(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Validate request
	Validate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfAssets request
	IdOfAssets(ctx context.Context, params *IdOfAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfAssetWithBody request with any body
	IdOfAssetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IdOfAsset(ctx context.Context, id string, body IdOfAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAsset request
	CreateAsset(ctx context.Context, params *CreateAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoices request
	ListInvoices(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoice request
	GetInvoice(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindCloudDiagramsWithBody request with any body
	FindCloudDiagramsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindCloudDiagrams(ctx context.Context, body FindCloudDiagramsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKnownIssues request
	ListKnownIssues(ctx context.Context, params *ListKnownIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKnownIssue request
	GetKnownIssue(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccountTeam request
	ListAccountTeam(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatahubEventsCSVFileWithBody request with any body
	DatahubEventsCSVFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatahubEventsWithBody request with any body
	DatahubEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatahubEvents(ctx context.Context, body DatahubEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatahubEventsByFilterWithBody request with any body
	DeleteDatahubEventsByFilterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteDatahubEventsByFilter(ctx context.Context, body DeleteDatahubEventsByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganizations request
	ListOrganizations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserWithBody request with any body
	InviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, id string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePermission request
	GetResourcePermission(ctx context.Context, resourceType GetResourcePermissionParamsResourceType, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourcePermissionWithBody request with any body
	UpdateResourcePermissionWithBody(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourcePermission(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, body UpdateResourcePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlatforms request
	ListPlatforms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProducts request
	ListProducts(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfTickets request
	IdOfTickets(ctx context.Context, params *IdOfTicketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdOfTicketsPostWithBody request with any body
	IdOfTicketsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IdOfTicketsPost(ctx context.Context, body IdOfTicketsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAlerts(ctx context.Context, params *ListAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlert(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAlertRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlert(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlertWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAlertRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlert(ctx context.Context, id string, body UpdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAlertRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllocations(ctx context.Context, params *ListAllocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAllocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAllocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAllocation(ctx context.Context, body CreateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAllocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllocation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllocationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllocation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllocationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAllocationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAllocationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAllocation(ctx context.Context, id string, body UpdateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAllocationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAnnotations(ctx context.Context, params *ListAnnotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAnnotationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnnotationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnnotationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnnotation(ctx context.Context, body CreateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnnotationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAnnotation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAnnotationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnnotation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnnotationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAnnotationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAnnotationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAnnotation(ctx context.Context, id string, body UpdateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAnnotationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttributionGroups(ctx context.Context, params *ListAttributionGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttributionGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttributionGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributionGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttributionGroup(ctx context.Context, body CreateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributionGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttributionGroup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttributionGroupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttributionGroup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttributionGroupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttributionGroupWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributionGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttributionGroup(ctx context.Context, id string, body UpdateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributionGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttributions(ctx context.Context, params *ListAttributionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttributionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttributionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttribution(ctx context.Context, body CreateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttribution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttributionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttribution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttributionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttributionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttribution(ctx context.Context, id string, body UpdateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBudgets(ctx context.Context, params *ListBudgetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBudgetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBudgetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBudgetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBudget(ctx context.Context, body CreateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBudgetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBudget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBudgetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudget(ctx context.Context, id string, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommitments(ctx context.Context, params *ListCommitmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommitmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommitment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitmentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDimensions(ctx context.Context, params *GetDimensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDimensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDimensions(ctx context.Context, params *ListDimensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDimensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLabels(ctx context.Context, params *ListLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLabelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLabelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLabel(ctx context.Context, body CreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLabelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLabel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLabelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLabelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLabelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLabel(ctx context.Context, id string, body UpdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLabelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignObjectsToLabelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignObjectsToLabelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignObjectsToLabel(ctx context.Context, id string, body AssignObjectsToLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignObjectsToLabelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReports(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReport(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Query(ctx context.Context, body QueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReport(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReportRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReport(ctx context.Context, id ReportId, params *GetReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReportWithBody(ctx context.Context, id ReportId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReportRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReport(ctx context.Context, id ReportId, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReportRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportConfig(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportConfigRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAnomalies(ctx context.Context, params *ListAnomaliesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAnomaliesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnomaly(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnomalyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Validate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfAssets(ctx context.Context, params *IdOfAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfAssetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfAssetRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfAsset(ctx context.Context, id string, body IdOfAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfAssetRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAsset(ctx context.Context, params *CreateAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoices(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoice(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCloudDiagramsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCloudDiagramsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCloudDiagrams(ctx context.Context, body FindCloudDiagramsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCloudDiagramsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKnownIssues(ctx context.Context, params *ListKnownIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKnownIssuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKnownIssue(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKnownIssueRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccountTeam(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountTeamRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatahubEventsCSVFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatahubEventsCSVFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatahubEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatahubEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatahubEvents(ctx context.Context, body DatahubEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatahubEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatahubEventsByFilterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatahubEventsByFilterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatahubEventsByFilter(ctx context.Context, body DeleteDatahubEventsByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatahubEventsByFilterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganizations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, id string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePermission(ctx context.Context, resourceType GetResourcePermissionParamsResourceType, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePermissionRequest(c.Server, resourceType, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourcePermissionWithBody(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourcePermissionRequestWithBody(c.Server, resourceType, resourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourcePermission(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, body UpdateResourcePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourcePermissionRequest(c.Server, resourceType, resourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlatforms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlatformsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProducts(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfTickets(ctx context.Context, params *IdOfTicketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfTicketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfTicketsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfTicketsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdOfTicketsPost(ctx context.Context, body IdOfTicketsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdOfTicketsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAlertsRequest generates requests for ListAlerts
func NewListAlertsRequest(server string, params *ListAlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAlertRequest calls the generic CreateAlert builder with application/json body
func NewCreateAlertRequest(server string, body CreateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAlertRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAlertRequestWithBody generates requests for CreateAlert with any type of body
func NewCreateAlertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAlertRequest generates requests for DeleteAlert
func NewDeleteAlertRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/alerts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlertRequest generates requests for GetAlert
func NewGetAlertRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/alerts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAlertRequest calls the generic UpdateAlert builder with application/json body
func NewUpdateAlertRequest(server string, id string, body UpdateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAlertRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAlertRequestWithBody generates requests for UpdateAlert with any type of body
func NewUpdateAlertRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/alerts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllocationsRequest generates requests for ListAllocations
func NewListAllocationsRequest(server string, params *ListAllocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/allocations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAllocationRequest calls the generic CreateAllocation builder with application/json body
func NewCreateAllocationRequest(server string, body CreateAllocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAllocationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAllocationRequestWithBody generates requests for CreateAllocation with any type of body
func NewCreateAllocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/allocations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllocationRequest generates requests for DeleteAllocation
func NewDeleteAllocationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/allocations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllocationRequest generates requests for GetAllocation
func NewGetAllocationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/allocations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAllocationRequest calls the generic UpdateAllocation builder with application/json body
func NewUpdateAllocationRequest(server string, id string, body UpdateAllocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAllocationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAllocationRequestWithBody generates requests for UpdateAllocation with any type of body
func NewUpdateAllocationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/allocations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAnnotationsRequest generates requests for ListAnnotations
func NewListAnnotationsRequest(server string, params *ListAnnotationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/annotations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAnnotationRequest calls the generic CreateAnnotation builder with application/json body
func NewCreateAnnotationRequest(server string, body CreateAnnotationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAnnotationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAnnotationRequestWithBody generates requests for CreateAnnotation with any type of body
func NewCreateAnnotationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/annotations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAnnotationRequest generates requests for DeleteAnnotation
func NewDeleteAnnotationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/annotations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnnotationRequest generates requests for GetAnnotation
func NewGetAnnotationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/annotations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAnnotationRequest calls the generic UpdateAnnotation builder with application/json body
func NewUpdateAnnotationRequest(server string, id string, body UpdateAnnotationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAnnotationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAnnotationRequestWithBody generates requests for UpdateAnnotation with any type of body
func NewUpdateAnnotationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/annotations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAttributionGroupsRequest generates requests for ListAttributionGroups
func NewListAttributionGroupsRequest(server string, params *ListAttributionGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributiongroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAttributionGroupRequest calls the generic CreateAttributionGroup builder with application/json body
func NewCreateAttributionGroupRequest(server string, body CreateAttributionGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAttributionGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAttributionGroupRequestWithBody generates requests for CreateAttributionGroup with any type of body
func NewCreateAttributionGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributiongroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAttributionGroupRequest generates requests for DeleteAttributionGroup
func NewDeleteAttributionGroupRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributiongroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttributionGroupRequest generates requests for GetAttributionGroup
func NewGetAttributionGroupRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributiongroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAttributionGroupRequest calls the generic UpdateAttributionGroup builder with application/json body
func NewUpdateAttributionGroupRequest(server string, id string, body UpdateAttributionGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttributionGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAttributionGroupRequestWithBody generates requests for UpdateAttributionGroup with any type of body
func NewUpdateAttributionGroupRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributiongroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAttributionsRequest generates requests for ListAttributions
func NewListAttributionsRequest(server string, params *ListAttributionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAttributionRequest calls the generic CreateAttribution builder with application/json body
func NewCreateAttributionRequest(server string, body CreateAttributionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAttributionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAttributionRequestWithBody generates requests for CreateAttribution with any type of body
func NewCreateAttributionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAttributionRequest generates requests for DeleteAttribution
func NewDeleteAttributionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttributionRequest generates requests for GetAttribution
func NewGetAttributionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAttributionRequest calls the generic UpdateAttribution builder with application/json body
func NewUpdateAttributionRequest(server string, id string, body UpdateAttributionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttributionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAttributionRequestWithBody generates requests for UpdateAttribution with any type of body
func NewUpdateAttributionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/attributions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBudgetsRequest generates requests for ListBudgets
func NewListBudgetsRequest(server string, params *ListBudgetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreationTime", runtime.ParamLocationQuery, *params.MinCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreationTime", runtime.ParamLocationQuery, *params.MaxCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBudgetRequest calls the generic CreateBudget builder with application/json body
func NewCreateBudgetRequest(server string, body CreateBudgetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBudgetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBudgetRequestWithBody generates requests for CreateBudget with any type of body
func NewCreateBudgetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBudgetRequest generates requests for DeleteBudget
func NewDeleteBudgetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBudgetRequest generates requests for GetBudget
func NewGetBudgetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBudgetRequest calls the generic UpdateBudget builder with application/json body
func NewUpdateBudgetRequest(server string, id string, body UpdateBudgetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBudgetRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateBudgetRequestWithBody generates requests for UpdateBudget with any type of body
func NewUpdateBudgetRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCommitmentsRequest generates requests for ListCommitments
func NewListCommitmentsRequest(server string, params *ListCommitmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/commitment-manager")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommitmentRequest generates requests for GetCommitment
func NewGetCommitmentRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/commitment-manager/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDimensionsRequest generates requests for GetDimensions
func NewGetDimensionsRequest(server string, params *GetDimensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/dimension")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDimensionsRequest generates requests for ListDimensions
func NewListDimensionsRequest(server string, params *ListDimensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/dimensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLabelsRequest generates requests for ListLabels
func NewListLabelsRequest(server string, params *ListLabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLabelRequest calls the generic CreateLabel builder with application/json body
func NewCreateLabelRequest(server string, body CreateLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLabelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLabelRequestWithBody generates requests for CreateLabel with any type of body
func NewCreateLabelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLabelRequest generates requests for DeleteLabel
func NewDeleteLabelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelRequest generates requests for GetLabel
func NewGetLabelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLabelRequest calls the generic UpdateLabel builder with application/json body
func NewUpdateLabelRequest(server string, id string, body UpdateLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLabelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLabelRequestWithBody generates requests for UpdateLabel with any type of body
func NewUpdateLabelRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignObjectsToLabelRequest calls the generic AssignObjectsToLabel builder with application/json body
func NewAssignObjectsToLabelRequest(server string, id string, body AssignObjectsToLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignObjectsToLabelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAssignObjectsToLabelRequestWithBody generates requests for AssignObjectsToLabel with any type of body
func NewAssignObjectsToLabelRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/labels/%s/assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReportsRequest generates requests for ListReports
func NewListReportsRequest(server string, params *ListReportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreationTime", runtime.ParamLocationQuery, *params.MinCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreationTime", runtime.ParamLocationQuery, *params.MaxCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReportRequest calls the generic CreateReport builder with application/json body
func NewCreateReportRequest(server string, body CreateReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateReportRequestWithBody generates requests for CreateReport with any type of body
func NewCreateReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryRequest calls the generic Query builder with application/json body
func NewQueryRequest(server string, body QueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryRequestWithBody generates requests for Query with any type of body
func NewQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReportRequest generates requests for DeleteReport
func NewDeleteReportRequest(server string, id ReportId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportRequest generates requests for GetReport
func NewGetReportRequest(server string, id ReportId, params *GetReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TimeRange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeRange", runtime.ParamLocationQuery, *params.TimeRange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReportRequest calls the generic UpdateReport builder with application/json body
func NewUpdateReportRequest(server string, id ReportId, body UpdateReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReportRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateReportRequestWithBody generates requests for UpdateReport with any type of body
func NewUpdateReportRequestWithBody(server string, id ReportId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReportConfigRequest generates requests for GetReportConfig
func NewGetReportConfigRequest(server string, id ReportId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/v1/reports/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAnomaliesRequest generates requests for ListAnomalies
func NewListAnomaliesRequest(server string, params *ListAnomaliesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anomalies/v1")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MinCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreationTime", runtime.ParamLocationQuery, *params.MinCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreationTime", runtime.ParamLocationQuery, *params.MaxCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnomalyRequest generates requests for GetAnomaly
func NewGetAnomalyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anomalies/v1/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateRequest generates requests for Validate
func NewValidateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/v1/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdOfAssetsRequest generates requests for IdOfAssets
func NewIdOfAssetsRequest(server string, params *IdOfAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing/v1/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdOfAssetRequest calls the generic IdOfAsset builder with application/json body
func NewIdOfAssetRequest(server string, id string, body IdOfAssetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdOfAssetRequestWithBody(server, id, "application/json", bodyReader)
}

// NewIdOfAssetRequestWithBody generates requests for IdOfAsset with any type of body
func NewIdOfAssetRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing/v1/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAssetRequest generates requests for CreateAsset
func NewCreateAssetRequest(server string, params *CreateAssetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing/v1/createAsset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountName", runtime.ParamLocationQuery, *params.AccountName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootEmail", runtime.ParamLocationQuery, *params.RootEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInvoicesRequest generates requests for ListInvoices
func NewListInvoicesRequest(server string, params *ListInvoicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing/v1/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreationTime", runtime.ParamLocationQuery, *params.MinCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreationTime", runtime.ParamLocationQuery, *params.MaxCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceRequest generates requests for GetInvoice
func NewGetInvoiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing/v1/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindCloudDiagramsRequest calls the generic FindCloudDiagrams builder with application/json body
func NewFindCloudDiagramsRequest(server string, body FindCloudDiagramsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindCloudDiagramsRequestWithBody(server, "application/json", bodyReader)
}

// NewFindCloudDiagramsRequestWithBody generates requests for FindCloudDiagrams with any type of body
func NewFindCloudDiagramsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clouddiagrams/v1/scheme/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListKnownIssuesRequest generates requests for ListKnownIssues
func NewListKnownIssuesRequest(server string, params *ListKnownIssuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/v1/cloudincidents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreationTime", runtime.ParamLocationQuery, *params.MinCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreationTime", runtime.ParamLocationQuery, *params.MaxCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKnownIssueRequest generates requests for GetKnownIssue
func NewGetKnownIssueRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/core/v1/cloudincidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAccountTeamRequest generates requests for ListAccountTeam
func NewListAccountTeamRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/v1/accountTeam")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatahubEventsCSVFileRequestWithBody generates requests for DatahubEventsCSVFile with any type of body
func NewDatahubEventsCSVFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datahub/v1/csv/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatahubEventsRequest calls the generic DatahubEvents builder with application/json body
func NewDatahubEventsRequest(server string, body DatahubEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatahubEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewDatahubEventsRequestWithBody generates requests for DatahubEvents with any type of body
func NewDatahubEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datahub/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatahubEventsByFilterRequest calls the generic DeleteDatahubEventsByFilter builder with application/json body
func NewDeleteDatahubEventsByFilterRequest(server string, body DeleteDatahubEventsByFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteDatahubEventsByFilterRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteDatahubEventsByFilterRequestWithBody generates requests for DeleteDatahubEventsByFilter with any type of body
func NewDeleteDatahubEventsByFilterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datahub/v1/events/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrganizationsRequest generates requests for ListOrganizations
func NewListOrganizationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/users/invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, id string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourcePermissionRequest generates requests for GetResourcePermission
func NewGetResourcePermissionRequest(server string, resourceType GetResourcePermissionParamsResourceType, resourceId ResourceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/v1/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourcePermissionRequest calls the generic UpdateResourcePermission builder with application/json body
func NewUpdateResourcePermissionRequest(server string, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, body UpdateResourcePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourcePermissionRequestWithBody(server, resourceType, resourceId, "application/json", bodyReader)
}

// NewUpdateResourcePermissionRequestWithBody generates requests for UpdateResourcePermission with any type of body
func NewUpdateResourcePermissionRequestWithBody(server string, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/v1/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPlatformsRequest generates requests for ListPlatforms
func NewListPlatformsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/support/v1/metadata/platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProductsRequest generates requests for ListProducts
func NewListProductsRequest(server string, params *ListProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/support/v1/metadata/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdOfTicketsRequest generates requests for IdOfTickets
func NewIdOfTicketsRequest(server string, params *IdOfTicketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/support/v1/tickets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreationTime", runtime.ParamLocationQuery, *params.MinCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreationTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreationTime", runtime.ParamLocationQuery, *params.MaxCreationTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdOfTicketsPostRequest calls the generic IdOfTicketsPost builder with application/json body
func NewIdOfTicketsPostRequest(server string, body IdOfTicketsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdOfTicketsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewIdOfTicketsPostRequestWithBody generates requests for IdOfTicketsPost with any type of body
func NewIdOfTicketsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/support/v1/tickets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAlertsWithResponse request
	ListAlertsWithResponse(ctx context.Context, params *ListAlertsParams, reqEditors ...RequestEditorFn) (*ListAlertsResp, error)

	// CreateAlertWithBodyWithResponse request with any body
	CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResp, error)

	CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResp, error)

	// DeleteAlertWithResponse request
	DeleteAlertWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAlertResp, error)

	// GetAlertWithResponse request
	GetAlertWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAlertResp, error)

	// UpdateAlertWithBodyWithResponse request with any body
	UpdateAlertWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAlertResp, error)

	UpdateAlertWithResponse(ctx context.Context, id string, body UpdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAlertResp, error)

	// ListAllocationsWithResponse request
	ListAllocationsWithResponse(ctx context.Context, params *ListAllocationsParams, reqEditors ...RequestEditorFn) (*ListAllocationsResp, error)

	// CreateAllocationWithBodyWithResponse request with any body
	CreateAllocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllocationResp, error)

	CreateAllocationWithResponse(ctx context.Context, body CreateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAllocationResp, error)

	// DeleteAllocationWithResponse request
	DeleteAllocationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAllocationResp, error)

	// GetAllocationWithResponse request
	GetAllocationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAllocationResp, error)

	// UpdateAllocationWithBodyWithResponse request with any body
	UpdateAllocationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAllocationResp, error)

	UpdateAllocationWithResponse(ctx context.Context, id string, body UpdateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAllocationResp, error)

	// ListAnnotationsWithResponse request
	ListAnnotationsWithResponse(ctx context.Context, params *ListAnnotationsParams, reqEditors ...RequestEditorFn) (*ListAnnotationsResp, error)

	// CreateAnnotationWithBodyWithResponse request with any body
	CreateAnnotationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnnotationResp, error)

	CreateAnnotationWithResponse(ctx context.Context, body CreateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnnotationResp, error)

	// DeleteAnnotationWithResponse request
	DeleteAnnotationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAnnotationResp, error)

	// GetAnnotationWithResponse request
	GetAnnotationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAnnotationResp, error)

	// UpdateAnnotationWithBodyWithResponse request with any body
	UpdateAnnotationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAnnotationResp, error)

	UpdateAnnotationWithResponse(ctx context.Context, id string, body UpdateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAnnotationResp, error)

	// ListAttributionGroupsWithResponse request
	ListAttributionGroupsWithResponse(ctx context.Context, params *ListAttributionGroupsParams, reqEditors ...RequestEditorFn) (*ListAttributionGroupsResp, error)

	// CreateAttributionGroupWithBodyWithResponse request with any body
	CreateAttributionGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributionGroupResp, error)

	CreateAttributionGroupWithResponse(ctx context.Context, body CreateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttributionGroupResp, error)

	// DeleteAttributionGroupWithResponse request
	DeleteAttributionGroupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAttributionGroupResp, error)

	// GetAttributionGroupWithResponse request
	GetAttributionGroupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttributionGroupResp, error)

	// UpdateAttributionGroupWithBodyWithResponse request with any body
	UpdateAttributionGroupWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributionGroupResp, error)

	UpdateAttributionGroupWithResponse(ctx context.Context, id string, body UpdateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttributionGroupResp, error)

	// ListAttributionsWithResponse request
	ListAttributionsWithResponse(ctx context.Context, params *ListAttributionsParams, reqEditors ...RequestEditorFn) (*ListAttributionsResp, error)

	// CreateAttributionWithBodyWithResponse request with any body
	CreateAttributionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributionResp, error)

	CreateAttributionWithResponse(ctx context.Context, body CreateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttributionResp, error)

	// DeleteAttributionWithResponse request
	DeleteAttributionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAttributionResp, error)

	// GetAttributionWithResponse request
	GetAttributionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttributionResp, error)

	// UpdateAttributionWithBodyWithResponse request with any body
	UpdateAttributionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributionResp, error)

	UpdateAttributionWithResponse(ctx context.Context, id string, body UpdateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttributionResp, error)

	// ListBudgetsWithResponse request
	ListBudgetsWithResponse(ctx context.Context, params *ListBudgetsParams, reqEditors ...RequestEditorFn) (*ListBudgetsResp, error)

	// CreateBudgetWithBodyWithResponse request with any body
	CreateBudgetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBudgetResp, error)

	CreateBudgetWithResponse(ctx context.Context, body CreateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBudgetResp, error)

	// DeleteBudgetWithResponse request
	DeleteBudgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBudgetResp, error)

	// GetBudgetWithResponse request
	GetBudgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBudgetResp, error)

	// UpdateBudgetWithBodyWithResponse request with any body
	UpdateBudgetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetResp, error)

	UpdateBudgetWithResponse(ctx context.Context, id string, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetResp, error)

	// ListCommitmentsWithResponse request
	ListCommitmentsWithResponse(ctx context.Context, params *ListCommitmentsParams, reqEditors ...RequestEditorFn) (*ListCommitmentsResp, error)

	// GetCommitmentWithResponse request
	GetCommitmentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCommitmentResp, error)

	// GetDimensionsWithResponse request
	GetDimensionsWithResponse(ctx context.Context, params *GetDimensionsParams, reqEditors ...RequestEditorFn) (*GetDimensionsResp, error)

	// ListDimensionsWithResponse request
	ListDimensionsWithResponse(ctx context.Context, params *ListDimensionsParams, reqEditors ...RequestEditorFn) (*ListDimensionsResp, error)

	// ListLabelsWithResponse request
	ListLabelsWithResponse(ctx context.Context, params *ListLabelsParams, reqEditors ...RequestEditorFn) (*ListLabelsResp, error)

	// CreateLabelWithBodyWithResponse request with any body
	CreateLabelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLabelResp, error)

	CreateLabelWithResponse(ctx context.Context, body CreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLabelResp, error)

	// DeleteLabelWithResponse request
	DeleteLabelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLabelResp, error)

	// GetLabelWithResponse request
	GetLabelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLabelResp, error)

	// UpdateLabelWithBodyWithResponse request with any body
	UpdateLabelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLabelResp, error)

	UpdateLabelWithResponse(ctx context.Context, id string, body UpdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLabelResp, error)

	// AssignObjectsToLabelWithBodyWithResponse request with any body
	AssignObjectsToLabelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignObjectsToLabelResp, error)

	AssignObjectsToLabelWithResponse(ctx context.Context, id string, body AssignObjectsToLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignObjectsToLabelResp, error)

	// ListReportsWithResponse request
	ListReportsWithResponse(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResp, error)

	// CreateReportWithBodyWithResponse request with any body
	CreateReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportResp, error)

	CreateReportWithResponse(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportResp, error)

	// QueryWithBodyWithResponse request with any body
	QueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryResp, error)

	QueryWithResponse(ctx context.Context, body QueryJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryResp, error)

	// DeleteReportWithResponse request
	DeleteReportWithResponse(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*DeleteReportResp, error)

	// GetReportWithResponse request
	GetReportWithResponse(ctx context.Context, id ReportId, params *GetReportParams, reqEditors ...RequestEditorFn) (*GetReportResp, error)

	// UpdateReportWithBodyWithResponse request with any body
	UpdateReportWithBodyWithResponse(ctx context.Context, id ReportId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReportResp, error)

	UpdateReportWithResponse(ctx context.Context, id ReportId, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReportResp, error)

	// GetReportConfigWithResponse request
	GetReportConfigWithResponse(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*GetReportConfigResp, error)

	// ListAnomaliesWithResponse request
	ListAnomaliesWithResponse(ctx context.Context, params *ListAnomaliesParams, reqEditors ...RequestEditorFn) (*ListAnomaliesResp, error)

	// GetAnomalyWithResponse request
	GetAnomalyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAnomalyResp, error)

	// ValidateWithResponse request
	ValidateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateResp, error)

	// IdOfAssetsWithResponse request
	IdOfAssetsWithResponse(ctx context.Context, params *IdOfAssetsParams, reqEditors ...RequestEditorFn) (*IdOfAssetsResp, error)

	// IdOfAssetWithBodyWithResponse request with any body
	IdOfAssetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfAssetResp, error)

	IdOfAssetWithResponse(ctx context.Context, id string, body IdOfAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfAssetResp, error)

	// CreateAssetWithResponse request
	CreateAssetWithResponse(ctx context.Context, params *CreateAssetParams, reqEditors ...RequestEditorFn) (*CreateAssetResp, error)

	// ListInvoicesWithResponse request
	ListInvoicesWithResponse(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*ListInvoicesResp, error)

	// GetInvoiceWithResponse request
	GetInvoiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetInvoiceResp, error)

	// FindCloudDiagramsWithBodyWithResponse request with any body
	FindCloudDiagramsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCloudDiagramsResp, error)

	FindCloudDiagramsWithResponse(ctx context.Context, body FindCloudDiagramsJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCloudDiagramsResp, error)

	// ListKnownIssuesWithResponse request
	ListKnownIssuesWithResponse(ctx context.Context, params *ListKnownIssuesParams, reqEditors ...RequestEditorFn) (*ListKnownIssuesResp, error)

	// GetKnownIssueWithResponse request
	GetKnownIssueWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKnownIssueResp, error)

	// ListAccountTeamWithResponse request
	ListAccountTeamWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAccountTeamResp, error)

	// DatahubEventsCSVFileWithBodyWithResponse request with any body
	DatahubEventsCSVFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatahubEventsCSVFileResp, error)

	// DatahubEventsWithBodyWithResponse request with any body
	DatahubEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatahubEventsResp, error)

	DatahubEventsWithResponse(ctx context.Context, body DatahubEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*DatahubEventsResp, error)

	// DeleteDatahubEventsByFilterWithBodyWithResponse request with any body
	DeleteDatahubEventsByFilterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDatahubEventsByFilterResp, error)

	DeleteDatahubEventsByFilterWithResponse(ctx context.Context, body DeleteDatahubEventsByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDatahubEventsByFilterResp, error)

	// ListOrganizationsWithResponse request
	ListOrganizationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrganizationsResp, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRolesResp, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResp, error)

	// InviteUserWithBodyWithResponse request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResp, error)

	InviteUserWithResponse(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResp, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserResp, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResp, error)

	UpdateUserWithResponse(ctx context.Context, id string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResp, error)

	// GetResourcePermissionWithResponse request
	GetResourcePermissionWithResponse(ctx context.Context, resourceType GetResourcePermissionParamsResourceType, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourcePermissionResp, error)

	// UpdateResourcePermissionWithBodyWithResponse request with any body
	UpdateResourcePermissionWithBodyWithResponse(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourcePermissionResp, error)

	UpdateResourcePermissionWithResponse(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, body UpdateResourcePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourcePermissionResp, error)

	// ListPlatformsWithResponse request
	ListPlatformsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlatformsResp, error)

	// ListProductsWithResponse request
	ListProductsWithResponse(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*ListProductsResp, error)

	// IdOfTicketsWithResponse request
	IdOfTicketsWithResponse(ctx context.Context, params *IdOfTicketsParams, reqEditors ...RequestEditorFn) (*IdOfTicketsResp, error)

	// IdOfTicketsPostWithBodyWithResponse request with any body
	IdOfTicketsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfTicketsPostResp, error)

	IdOfTicketsPostWithResponse(ctx context.Context, body IdOfTicketsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfTicketsPostResp, error)
}

type ListAlertsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalAlertList
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListAlertsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAlertsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAlertResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Alert
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateAlertResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAlertResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAlertResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r DeleteAlertResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAlertResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Alert
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetAlertResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAlertResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Alert
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateAlertResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAlertResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllocationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Allocations *[]AllocationListItem `json:"allocations,omitempty"`

		// PageToken Page token, returned by a previous call, to request the next page of results.
		PageToken *string `json:"pageToken,omitempty"`

		// RowCount Total number of allocations in the result set.
		RowCount *int `json:"rowCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ListAllocationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllocationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAllocationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NewAllocationResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateAllocationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAllocationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllocationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *[]AllocationDeleteValidation
}

// Status returns HTTPResponse.Status
func (r DeleteAllocationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllocationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllocationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Allocation
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetAllocationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllocationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAllocationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NewAllocationResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateAllocationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAllocationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAnnotationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Annotations *[]AnnotationListItem `json:"annotations,omitempty"`

		// PageToken Page token, returned by a previous call, to request the next page of results
		PageToken *string `json:"pageToken,omitempty"`

		// RowCount Total number of annotations in the result set
		RowCount *int `json:"rowCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ListAnnotationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAnnotationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAnnotationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AnnotationListItem
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateAnnotationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAnnotationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAnnotationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r DeleteAnnotationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAnnotationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnnotationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnnotationListItem
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetAnnotationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnnotationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAnnotationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnnotationListItem
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateAnnotationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAnnotationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttributionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttributionGroupsListExternal
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListAttributionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttributionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAttributionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateAttributionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAttributionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttributionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *[]AttributionGroupDeleteValidation
}

// Status returns HTTPResponse.Status
func (r DeleteAttributionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttributionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttributionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttributionGroupGetExternal
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAttributionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttributionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttributionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateAttributionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttributionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttributionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Attributions Summary information for an attribution.
		Attributions *AttributionListItem `json:"Attributions,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ListAttributionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttributionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAttributionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateAttributionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAttributionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttributionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *[]AttributionDeleteValidation
}

// Status returns HTTPResponse.Status
func (r DeleteAttributionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttributionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttributionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Attribution Definition and metadata of an attribution.
		Attribution *AttributionAPI `json:"Attribution,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r GetAttributionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttributionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttributionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateAttributionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttributionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBudgetsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Budgets Array of Budgets
		Budgets *[]BudgetListItem `json:"budgets,omitempty"`

		// PageToken Page token, returned by a previous call, to request the next page of results
		PageToken *string `json:"pageToken,omitempty"`

		// RowCount Budgets rows count
		RowCount *int64 `json:"rowCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ListBudgetsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBudgetsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBudgetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BudgetAPI
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateBudgetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBudgetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBudgetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r DeleteBudgetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBudgetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BudgetAPI
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetBudgetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBudgetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BudgetAPI
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateBudgetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBudgetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommitmentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitmentExternalList
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListCommitmentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommitmentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitmentExternal
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetCommitmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDimensionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DimensionsExternalAPIGetResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetDimensionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDimensionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDimensionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DimensionsExternalAPIList
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListDimensionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDimensionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLabelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabelList
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListLabelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLabelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LabelListItem
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r DeleteLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabelListItem
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r GetLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabelListItem
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r UpdateLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignObjectsToLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r AssignObjectsToLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignObjectsToLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportList
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id ID of the new report.
		Id *string `json:"id,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r CreateReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunReportResult
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r QueryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreateTime The creation time of the report, in milliseconds since the epoch.
		CreateTime *int64 `json:"createTime,omitempty"`

		// Id Report ID.
		Id *string `json:"id,omitempty"`

		// Owner Email address of the report owner.
		Owner *string `json:"owner,omitempty"`

		// ReportName The name of the report.
		ReportName *string `json:"reportName,omitempty"`
		Result     *struct {
			// CacheHit If true, results were fetched from the cache.
			CacheHit     *bool                           `json:"cacheHit,omitempty"`
			ForecastRows *[][]Value                      `json:"forecastRows,omitempty"`
			MlFeatures   *[]GetReport200ResultMlFeatures `json:"mlFeatures,omitempty"`
			Rows         *[][]Value                      `json:"rows,omitempty"`
			Schema       *[]SchemaField                  `json:"schema,omitempty"`
		} `json:"result,omitempty"`
		Type *GetReport200Type `json:"type,omitempty"`

		// UpdateTime The time when this report was last updated, in milliseconds since the epoch.
		UpdateTime *int64 `json:"updateTime,omitempty"`

		// UrlUI The URL of the report in DoiT console.
		UrlUI *string `json:"urlUI,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
	JSON429 *N429
}
type GetReport200ResultMlFeatures string
type GetReport200Type string

// Status returns HTTPResponse.Status
func (r GetReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id ID of the updated report.
		Id *string `json:"id,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r UpdateReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalReport
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetReportConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAnomaliesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnomaliesResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r ListAnomaliesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAnomaliesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnomalyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Acknowledged Has the anomaly been acknowledged
		Acknowledged *bool `json:"acknowledged,omitempty"`

		// Attribution Attribution ID
		Attribution string `json:"attribution"`

		// BillingAccount Billing account ID
		BillingAccount string `json:"billingAccount"`

		// CostOfAnomaly The difference between the actual cost and the maximum cost in the normal range.
		CostOfAnomaly float64 `json:"costOfAnomaly"`

		// EndTime End of the anomaly
		EndTime *int `json:"endTime"`

		// Platform Cloud Provider name
		Platform string `json:"platform"`

		// ResourceData Array of resources contributing to an anomaly.
		ResourceData *AnomalyResourceArray `json:"resourceData,omitempty"`

		// Scope Scope: Project or Account
		Scope string `json:"scope"`

		// ServiceName Service name
		ServiceName string `json:"serviceName"`

		// SeverityLevel Severity level: Information, Warning or Critical
		SeverityLevel string `json:"severityLevel"`

		// StartTime Usage start time of the anomaly
		StartTime int64                `json:"startTime"`
		Status    *GetAnomaly200Status `json:"status"`

		// TimeFrame Timeframe: Daily or Hourly
		TimeFrame string `json:"timeFrame"`

		// Top3SKUs Array of SKU entries contributing to an anomaly.
		Top3SKUs AnomalySKUArray `json:"top3SKUs"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}
type GetAnomaly200Status string

// Status returns HTTPResponse.Status
func (r GetAnomalyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnomalyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
}

// Status returns HTTPResponse.Status
func (r ValidateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfAssetsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Assets Array of Assets
		Assets *[]AssetItem `json:"assets,omitempty"`

		// PageToken Page token. Can be used to request the next page of results.
		PageToken *string `json:"pageToken,omitempty"`

		// RowCount Assets rows count
		RowCount *int64 `json:"rowCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r IdOfAssetsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfAssetsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfAssetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id *string `json:"id,omitempty"`

		// Properties Additional properties associated with an asset.
		Properties *AssetProperties `json:"properties,omitempty"`
		Type       *string          `json:"type,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r IdOfAssetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfAssetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r CreateAssetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Invoices Array of Invoices
		Invoices *[]InvoiceListItem `json:"invoices,omitempty"`

		// PageToken Page token. Can be used to request the next page of results.
		PageToken *string `json:"pageToken,omitempty"`

		// RowCount Invoice rows count
		RowCount *int64 `json:"rowCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ListInvoicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BalanceAmount Invoice balance to be paid
		BalanceAmount *float64 `json:"balanceAmount,omitempty"`

		// Currency Currency code for monetary values.
		Currency *Currency `json:"currency,omitempty"`

		// DueDate The last day to pay the invoice, in milliseconds since the epoch
		DueDate *int64 `json:"dueDate,omitempty"`

		// Id Invoice number, identifying the invoice.
		Id *string `json:"id,omitempty"`

		// InvoiceDate The time when this invoice was issued, in milliseconds since the epoch.
		InvoiceDate *int64 `json:"invoiceDate,omitempty"`

		// LineItems Invoice line items.
		LineItems *[]ListItem `json:"lineItems,omitempty"`

		// Platform Platform identifier for invoice source.
		Platform *InvoicePlatform `json:"platform,omitempty"`

		// Status Status of the invoice
		Status *GetInvoice200Status `json:"status,omitempty"`

		// TotalAmount Total invoiced amount
		TotalAmount *float64 `json:"totalAmount,omitempty"`

		// Url Link to [invoice details page](https://help.doit.com/docs/billing/invoices-and-payments/managing-invoices) in the DoiT console. You can download the PDF invoice from the invoice details page.
		Url *string `json:"url,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}
type GetInvoice200Status string

// Status returns HTTPResponse.Status
func (r GetInvoiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCloudDiagramsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindCloudDiagramsResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
}

// Status returns HTTPResponse.Status
func (r FindCloudDiagramsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCloudDiagramsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKnownIssuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Incidents Array of cloud incidents
		Incidents *[]CloudIncidentListItem `json:"incidents,omitempty"`

		// PageToken Page token, returned by a previous call, to request the next page of results
		PageToken *string `json:"pageToken,omitempty"`

		// RowCount Cloud incidents rows count
		RowCount *int64 `json:"rowCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}

// Status returns HTTPResponse.Status
func (r ListKnownIssuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKnownIssuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKnownIssueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreateTime The time when this cloud incident was created, in milliseconds since the epoch.
		CreateTime *int64 `json:"createTime,omitempty"`

		// Description Detailed explanation on the cloud incident.
		Description *string `json:"description,omitempty"`

		// Id The unique id of a cloud incident
		Id *string `json:"id,omitempty"`

		// Platform The cloud platform.
		Platform *GetKnownIssue200Platform `json:"platform,omitempty"`

		// Product The name of the product affected by the cloud incident
		Product *string `json:"product,omitempty"`

		// Status The Status of the issue
		Status *GetKnownIssue200Status `json:"status,omitempty"`

		// Summary A summary of the cloud incident.
		Summary *string `json:"summary,omitempty"`

		// Symptoms Cloud incident symptoms, if available.
		Symptoms *string `json:"symptoms,omitempty"`

		// Title Cloud incident name provided by the cloud vendor.
		Title *string `json:"title,omitempty"`

		// Workaround Mitigation workaround for the cloud incident, if available.
		Workaround *string `json:"workaround,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
}
type GetKnownIssue200Platform string
type GetKnownIssue200Status string

// Status returns HTTPResponse.Status
func (r GetKnownIssueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKnownIssueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountTeamResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountManagers *[]AccountManagerListItem `json:"accountManagers,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
}

// Status returns HTTPResponse.Status
func (r ListAccountTeamResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountTeamResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatahubEventsCSVFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Batch batch id, generated during ingestion
		Batch *string `json:"batch,omitempty"`

		// IngestedRows the number of events that have been accepted for processing
		IngestedRows *int `json:"ingestedRows,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r DatahubEventsCSVFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatahubEventsCSVFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatahubEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r DatahubEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatahubEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatahubEventsByFilterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r DeleteDatahubEventsByFilterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatahubEventsByFilterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganizationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Organization
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListOrganizationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Roles *[]Role `json:"roles,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r ListRolesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersResponseBody
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *InviteResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r InviteUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteUserResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r UpdateUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePermissionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourcePermissionsResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetResourcePermissionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePermissionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourcePermissionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourcePermissionsResponse
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r UpdateResourcePermissionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourcePermissionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlatformsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Platforms *[]PlatformAPI `json:"platforms,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
}

// Status returns HTTPResponse.Status
func (r ListPlatformsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlatformsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Products *[]ProductAPI `json:"products,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
}

// Status returns HTTPResponse.Status
func (r ListProductsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfTicketsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TicketsList
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r IdOfTicketsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfTicketsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdOfTicketsPostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TicketResponseExtAPI
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r IdOfTicketsPostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdOfTicketsPostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAlertsWithResponse request returning *ListAlertsResp
func (c *ClientWithResponses) ListAlertsWithResponse(ctx context.Context, params *ListAlertsParams, reqEditors ...RequestEditorFn) (*ListAlertsResp, error) {
	rsp, err := c.ListAlerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAlertsResp(rsp)
}

// CreateAlertWithBodyWithResponse request with arbitrary body returning *CreateAlertResp
func (c *ClientWithResponses) CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResp, error) {
	rsp, err := c.CreateAlertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResp(rsp)
}

func (c *ClientWithResponses) CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResp, error) {
	rsp, err := c.CreateAlert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResp(rsp)
}

// DeleteAlertWithResponse request returning *DeleteAlertResp
func (c *ClientWithResponses) DeleteAlertWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAlertResp, error) {
	rsp, err := c.DeleteAlert(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAlertResp(rsp)
}

// GetAlertWithResponse request returning *GetAlertResp
func (c *ClientWithResponses) GetAlertWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAlertResp, error) {
	rsp, err := c.GetAlert(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertResp(rsp)
}

// UpdateAlertWithBodyWithResponse request with arbitrary body returning *UpdateAlertResp
func (c *ClientWithResponses) UpdateAlertWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAlertResp, error) {
	rsp, err := c.UpdateAlertWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAlertResp(rsp)
}

func (c *ClientWithResponses) UpdateAlertWithResponse(ctx context.Context, id string, body UpdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAlertResp, error) {
	rsp, err := c.UpdateAlert(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAlertResp(rsp)
}

// ListAllocationsWithResponse request returning *ListAllocationsResp
func (c *ClientWithResponses) ListAllocationsWithResponse(ctx context.Context, params *ListAllocationsParams, reqEditors ...RequestEditorFn) (*ListAllocationsResp, error) {
	rsp, err := c.ListAllocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllocationsResp(rsp)
}

// CreateAllocationWithBodyWithResponse request with arbitrary body returning *CreateAllocationResp
func (c *ClientWithResponses) CreateAllocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllocationResp, error) {
	rsp, err := c.CreateAllocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAllocationResp(rsp)
}

func (c *ClientWithResponses) CreateAllocationWithResponse(ctx context.Context, body CreateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAllocationResp, error) {
	rsp, err := c.CreateAllocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAllocationResp(rsp)
}

// DeleteAllocationWithResponse request returning *DeleteAllocationResp
func (c *ClientWithResponses) DeleteAllocationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAllocationResp, error) {
	rsp, err := c.DeleteAllocation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllocationResp(rsp)
}

// GetAllocationWithResponse request returning *GetAllocationResp
func (c *ClientWithResponses) GetAllocationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAllocationResp, error) {
	rsp, err := c.GetAllocation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllocationResp(rsp)
}

// UpdateAllocationWithBodyWithResponse request with arbitrary body returning *UpdateAllocationResp
func (c *ClientWithResponses) UpdateAllocationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAllocationResp, error) {
	rsp, err := c.UpdateAllocationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAllocationResp(rsp)
}

func (c *ClientWithResponses) UpdateAllocationWithResponse(ctx context.Context, id string, body UpdateAllocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAllocationResp, error) {
	rsp, err := c.UpdateAllocation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAllocationResp(rsp)
}

// ListAnnotationsWithResponse request returning *ListAnnotationsResp
func (c *ClientWithResponses) ListAnnotationsWithResponse(ctx context.Context, params *ListAnnotationsParams, reqEditors ...RequestEditorFn) (*ListAnnotationsResp, error) {
	rsp, err := c.ListAnnotations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAnnotationsResp(rsp)
}

// CreateAnnotationWithBodyWithResponse request with arbitrary body returning *CreateAnnotationResp
func (c *ClientWithResponses) CreateAnnotationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnnotationResp, error) {
	rsp, err := c.CreateAnnotationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnnotationResp(rsp)
}

func (c *ClientWithResponses) CreateAnnotationWithResponse(ctx context.Context, body CreateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnnotationResp, error) {
	rsp, err := c.CreateAnnotation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnnotationResp(rsp)
}

// DeleteAnnotationWithResponse request returning *DeleteAnnotationResp
func (c *ClientWithResponses) DeleteAnnotationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAnnotationResp, error) {
	rsp, err := c.DeleteAnnotation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAnnotationResp(rsp)
}

// GetAnnotationWithResponse request returning *GetAnnotationResp
func (c *ClientWithResponses) GetAnnotationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAnnotationResp, error) {
	rsp, err := c.GetAnnotation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnnotationResp(rsp)
}

// UpdateAnnotationWithBodyWithResponse request with arbitrary body returning *UpdateAnnotationResp
func (c *ClientWithResponses) UpdateAnnotationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAnnotationResp, error) {
	rsp, err := c.UpdateAnnotationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAnnotationResp(rsp)
}

func (c *ClientWithResponses) UpdateAnnotationWithResponse(ctx context.Context, id string, body UpdateAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAnnotationResp, error) {
	rsp, err := c.UpdateAnnotation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAnnotationResp(rsp)
}

// ListAttributionGroupsWithResponse request returning *ListAttributionGroupsResp
func (c *ClientWithResponses) ListAttributionGroupsWithResponse(ctx context.Context, params *ListAttributionGroupsParams, reqEditors ...RequestEditorFn) (*ListAttributionGroupsResp, error) {
	rsp, err := c.ListAttributionGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttributionGroupsResp(rsp)
}

// CreateAttributionGroupWithBodyWithResponse request with arbitrary body returning *CreateAttributionGroupResp
func (c *ClientWithResponses) CreateAttributionGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributionGroupResp, error) {
	rsp, err := c.CreateAttributionGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributionGroupResp(rsp)
}

func (c *ClientWithResponses) CreateAttributionGroupWithResponse(ctx context.Context, body CreateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttributionGroupResp, error) {
	rsp, err := c.CreateAttributionGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributionGroupResp(rsp)
}

// DeleteAttributionGroupWithResponse request returning *DeleteAttributionGroupResp
func (c *ClientWithResponses) DeleteAttributionGroupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAttributionGroupResp, error) {
	rsp, err := c.DeleteAttributionGroup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttributionGroupResp(rsp)
}

// GetAttributionGroupWithResponse request returning *GetAttributionGroupResp
func (c *ClientWithResponses) GetAttributionGroupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttributionGroupResp, error) {
	rsp, err := c.GetAttributionGroup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttributionGroupResp(rsp)
}

// UpdateAttributionGroupWithBodyWithResponse request with arbitrary body returning *UpdateAttributionGroupResp
func (c *ClientWithResponses) UpdateAttributionGroupWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributionGroupResp, error) {
	rsp, err := c.UpdateAttributionGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributionGroupResp(rsp)
}

func (c *ClientWithResponses) UpdateAttributionGroupWithResponse(ctx context.Context, id string, body UpdateAttributionGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttributionGroupResp, error) {
	rsp, err := c.UpdateAttributionGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributionGroupResp(rsp)
}

// ListAttributionsWithResponse request returning *ListAttributionsResp
func (c *ClientWithResponses) ListAttributionsWithResponse(ctx context.Context, params *ListAttributionsParams, reqEditors ...RequestEditorFn) (*ListAttributionsResp, error) {
	rsp, err := c.ListAttributions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttributionsResp(rsp)
}

// CreateAttributionWithBodyWithResponse request with arbitrary body returning *CreateAttributionResp
func (c *ClientWithResponses) CreateAttributionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributionResp, error) {
	rsp, err := c.CreateAttributionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributionResp(rsp)
}

func (c *ClientWithResponses) CreateAttributionWithResponse(ctx context.Context, body CreateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttributionResp, error) {
	rsp, err := c.CreateAttribution(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributionResp(rsp)
}

// DeleteAttributionWithResponse request returning *DeleteAttributionResp
func (c *ClientWithResponses) DeleteAttributionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAttributionResp, error) {
	rsp, err := c.DeleteAttribution(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttributionResp(rsp)
}

// GetAttributionWithResponse request returning *GetAttributionResp
func (c *ClientWithResponses) GetAttributionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttributionResp, error) {
	rsp, err := c.GetAttribution(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttributionResp(rsp)
}

// UpdateAttributionWithBodyWithResponse request with arbitrary body returning *UpdateAttributionResp
func (c *ClientWithResponses) UpdateAttributionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributionResp, error) {
	rsp, err := c.UpdateAttributionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributionResp(rsp)
}

func (c *ClientWithResponses) UpdateAttributionWithResponse(ctx context.Context, id string, body UpdateAttributionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttributionResp, error) {
	rsp, err := c.UpdateAttribution(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributionResp(rsp)
}

// ListBudgetsWithResponse request returning *ListBudgetsResp
func (c *ClientWithResponses) ListBudgetsWithResponse(ctx context.Context, params *ListBudgetsParams, reqEditors ...RequestEditorFn) (*ListBudgetsResp, error) {
	rsp, err := c.ListBudgets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBudgetsResp(rsp)
}

// CreateBudgetWithBodyWithResponse request with arbitrary body returning *CreateBudgetResp
func (c *ClientWithResponses) CreateBudgetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBudgetResp, error) {
	rsp, err := c.CreateBudgetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBudgetResp(rsp)
}

func (c *ClientWithResponses) CreateBudgetWithResponse(ctx context.Context, body CreateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBudgetResp, error) {
	rsp, err := c.CreateBudget(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBudgetResp(rsp)
}

// DeleteBudgetWithResponse request returning *DeleteBudgetResp
func (c *ClientWithResponses) DeleteBudgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBudgetResp, error) {
	rsp, err := c.DeleteBudget(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBudgetResp(rsp)
}

// GetBudgetWithResponse request returning *GetBudgetResp
func (c *ClientWithResponses) GetBudgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBudgetResp, error) {
	rsp, err := c.GetBudget(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetResp(rsp)
}

// UpdateBudgetWithBodyWithResponse request with arbitrary body returning *UpdateBudgetResp
func (c *ClientWithResponses) UpdateBudgetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetResp, error) {
	rsp, err := c.UpdateBudgetWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetResp(rsp)
}

func (c *ClientWithResponses) UpdateBudgetWithResponse(ctx context.Context, id string, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetResp, error) {
	rsp, err := c.UpdateBudget(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetResp(rsp)
}

// ListCommitmentsWithResponse request returning *ListCommitmentsResp
func (c *ClientWithResponses) ListCommitmentsWithResponse(ctx context.Context, params *ListCommitmentsParams, reqEditors ...RequestEditorFn) (*ListCommitmentsResp, error) {
	rsp, err := c.ListCommitments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommitmentsResp(rsp)
}

// GetCommitmentWithResponse request returning *GetCommitmentResp
func (c *ClientWithResponses) GetCommitmentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCommitmentResp, error) {
	rsp, err := c.GetCommitment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitmentResp(rsp)
}

// GetDimensionsWithResponse request returning *GetDimensionsResp
func (c *ClientWithResponses) GetDimensionsWithResponse(ctx context.Context, params *GetDimensionsParams, reqEditors ...RequestEditorFn) (*GetDimensionsResp, error) {
	rsp, err := c.GetDimensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDimensionsResp(rsp)
}

// ListDimensionsWithResponse request returning *ListDimensionsResp
func (c *ClientWithResponses) ListDimensionsWithResponse(ctx context.Context, params *ListDimensionsParams, reqEditors ...RequestEditorFn) (*ListDimensionsResp, error) {
	rsp, err := c.ListDimensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDimensionsResp(rsp)
}

// ListLabelsWithResponse request returning *ListLabelsResp
func (c *ClientWithResponses) ListLabelsWithResponse(ctx context.Context, params *ListLabelsParams, reqEditors ...RequestEditorFn) (*ListLabelsResp, error) {
	rsp, err := c.ListLabels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLabelsResp(rsp)
}

// CreateLabelWithBodyWithResponse request with arbitrary body returning *CreateLabelResp
func (c *ClientWithResponses) CreateLabelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLabelResp, error) {
	rsp, err := c.CreateLabelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLabelResp(rsp)
}

func (c *ClientWithResponses) CreateLabelWithResponse(ctx context.Context, body CreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLabelResp, error) {
	rsp, err := c.CreateLabel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLabelResp(rsp)
}

// DeleteLabelWithResponse request returning *DeleteLabelResp
func (c *ClientWithResponses) DeleteLabelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLabelResp, error) {
	rsp, err := c.DeleteLabel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLabelResp(rsp)
}

// GetLabelWithResponse request returning *GetLabelResp
func (c *ClientWithResponses) GetLabelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLabelResp, error) {
	rsp, err := c.GetLabel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelResp(rsp)
}

// UpdateLabelWithBodyWithResponse request with arbitrary body returning *UpdateLabelResp
func (c *ClientWithResponses) UpdateLabelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLabelResp, error) {
	rsp, err := c.UpdateLabelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLabelResp(rsp)
}

func (c *ClientWithResponses) UpdateLabelWithResponse(ctx context.Context, id string, body UpdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLabelResp, error) {
	rsp, err := c.UpdateLabel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLabelResp(rsp)
}

// AssignObjectsToLabelWithBodyWithResponse request with arbitrary body returning *AssignObjectsToLabelResp
func (c *ClientWithResponses) AssignObjectsToLabelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignObjectsToLabelResp, error) {
	rsp, err := c.AssignObjectsToLabelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignObjectsToLabelResp(rsp)
}

func (c *ClientWithResponses) AssignObjectsToLabelWithResponse(ctx context.Context, id string, body AssignObjectsToLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignObjectsToLabelResp, error) {
	rsp, err := c.AssignObjectsToLabel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignObjectsToLabelResp(rsp)
}

// ListReportsWithResponse request returning *ListReportsResp
func (c *ClientWithResponses) ListReportsWithResponse(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResp, error) {
	rsp, err := c.ListReports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportsResp(rsp)
}

// CreateReportWithBodyWithResponse request with arbitrary body returning *CreateReportResp
func (c *ClientWithResponses) CreateReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportResp, error) {
	rsp, err := c.CreateReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportResp(rsp)
}

func (c *ClientWithResponses) CreateReportWithResponse(ctx context.Context, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportResp, error) {
	rsp, err := c.CreateReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportResp(rsp)
}

// QueryWithBodyWithResponse request with arbitrary body returning *QueryResp
func (c *ClientWithResponses) QueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryResp, error) {
	rsp, err := c.QueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryResp(rsp)
}

func (c *ClientWithResponses) QueryWithResponse(ctx context.Context, body QueryJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryResp, error) {
	rsp, err := c.Query(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryResp(rsp)
}

// DeleteReportWithResponse request returning *DeleteReportResp
func (c *ClientWithResponses) DeleteReportWithResponse(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*DeleteReportResp, error) {
	rsp, err := c.DeleteReport(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReportResp(rsp)
}

// GetReportWithResponse request returning *GetReportResp
func (c *ClientWithResponses) GetReportWithResponse(ctx context.Context, id ReportId, params *GetReportParams, reqEditors ...RequestEditorFn) (*GetReportResp, error) {
	rsp, err := c.GetReport(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportResp(rsp)
}

// UpdateReportWithBodyWithResponse request with arbitrary body returning *UpdateReportResp
func (c *ClientWithResponses) UpdateReportWithBodyWithResponse(ctx context.Context, id ReportId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReportResp, error) {
	rsp, err := c.UpdateReportWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReportResp(rsp)
}

func (c *ClientWithResponses) UpdateReportWithResponse(ctx context.Context, id ReportId, body UpdateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReportResp, error) {
	rsp, err := c.UpdateReport(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReportResp(rsp)
}

// GetReportConfigWithResponse request returning *GetReportConfigResp
func (c *ClientWithResponses) GetReportConfigWithResponse(ctx context.Context, id ReportId, reqEditors ...RequestEditorFn) (*GetReportConfigResp, error) {
	rsp, err := c.GetReportConfig(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportConfigResp(rsp)
}

// ListAnomaliesWithResponse request returning *ListAnomaliesResp
func (c *ClientWithResponses) ListAnomaliesWithResponse(ctx context.Context, params *ListAnomaliesParams, reqEditors ...RequestEditorFn) (*ListAnomaliesResp, error) {
	rsp, err := c.ListAnomalies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAnomaliesResp(rsp)
}

// GetAnomalyWithResponse request returning *GetAnomalyResp
func (c *ClientWithResponses) GetAnomalyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAnomalyResp, error) {
	rsp, err := c.GetAnomaly(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnomalyResp(rsp)
}

// ValidateWithResponse request returning *ValidateResp
func (c *ClientWithResponses) ValidateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateResp, error) {
	rsp, err := c.Validate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateResp(rsp)
}

// IdOfAssetsWithResponse request returning *IdOfAssetsResp
func (c *ClientWithResponses) IdOfAssetsWithResponse(ctx context.Context, params *IdOfAssetsParams, reqEditors ...RequestEditorFn) (*IdOfAssetsResp, error) {
	rsp, err := c.IdOfAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfAssetsResp(rsp)
}

// IdOfAssetWithBodyWithResponse request with arbitrary body returning *IdOfAssetResp
func (c *ClientWithResponses) IdOfAssetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfAssetResp, error) {
	rsp, err := c.IdOfAssetWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfAssetResp(rsp)
}

func (c *ClientWithResponses) IdOfAssetWithResponse(ctx context.Context, id string, body IdOfAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfAssetResp, error) {
	rsp, err := c.IdOfAsset(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfAssetResp(rsp)
}

// CreateAssetWithResponse request returning *CreateAssetResp
func (c *ClientWithResponses) CreateAssetWithResponse(ctx context.Context, params *CreateAssetParams, reqEditors ...RequestEditorFn) (*CreateAssetResp, error) {
	rsp, err := c.CreateAsset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetResp(rsp)
}

// ListInvoicesWithResponse request returning *ListInvoicesResp
func (c *ClientWithResponses) ListInvoicesWithResponse(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*ListInvoicesResp, error) {
	rsp, err := c.ListInvoices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesResp(rsp)
}

// GetInvoiceWithResponse request returning *GetInvoiceResp
func (c *ClientWithResponses) GetInvoiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetInvoiceResp, error) {
	rsp, err := c.GetInvoice(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceResp(rsp)
}

// FindCloudDiagramsWithBodyWithResponse request with arbitrary body returning *FindCloudDiagramsResp
func (c *ClientWithResponses) FindCloudDiagramsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCloudDiagramsResp, error) {
	rsp, err := c.FindCloudDiagramsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCloudDiagramsResp(rsp)
}

func (c *ClientWithResponses) FindCloudDiagramsWithResponse(ctx context.Context, body FindCloudDiagramsJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCloudDiagramsResp, error) {
	rsp, err := c.FindCloudDiagrams(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCloudDiagramsResp(rsp)
}

// ListKnownIssuesWithResponse request returning *ListKnownIssuesResp
func (c *ClientWithResponses) ListKnownIssuesWithResponse(ctx context.Context, params *ListKnownIssuesParams, reqEditors ...RequestEditorFn) (*ListKnownIssuesResp, error) {
	rsp, err := c.ListKnownIssues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKnownIssuesResp(rsp)
}

// GetKnownIssueWithResponse request returning *GetKnownIssueResp
func (c *ClientWithResponses) GetKnownIssueWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKnownIssueResp, error) {
	rsp, err := c.GetKnownIssue(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKnownIssueResp(rsp)
}

// ListAccountTeamWithResponse request returning *ListAccountTeamResp
func (c *ClientWithResponses) ListAccountTeamWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAccountTeamResp, error) {
	rsp, err := c.ListAccountTeam(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountTeamResp(rsp)
}

// DatahubEventsCSVFileWithBodyWithResponse request with arbitrary body returning *DatahubEventsCSVFileResp
func (c *ClientWithResponses) DatahubEventsCSVFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatahubEventsCSVFileResp, error) {
	rsp, err := c.DatahubEventsCSVFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatahubEventsCSVFileResp(rsp)
}

// DatahubEventsWithBodyWithResponse request with arbitrary body returning *DatahubEventsResp
func (c *ClientWithResponses) DatahubEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatahubEventsResp, error) {
	rsp, err := c.DatahubEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatahubEventsResp(rsp)
}

func (c *ClientWithResponses) DatahubEventsWithResponse(ctx context.Context, body DatahubEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*DatahubEventsResp, error) {
	rsp, err := c.DatahubEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatahubEventsResp(rsp)
}

// DeleteDatahubEventsByFilterWithBodyWithResponse request with arbitrary body returning *DeleteDatahubEventsByFilterResp
func (c *ClientWithResponses) DeleteDatahubEventsByFilterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDatahubEventsByFilterResp, error) {
	rsp, err := c.DeleteDatahubEventsByFilterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatahubEventsByFilterResp(rsp)
}

func (c *ClientWithResponses) DeleteDatahubEventsByFilterWithResponse(ctx context.Context, body DeleteDatahubEventsByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDatahubEventsByFilterResp, error) {
	rsp, err := c.DeleteDatahubEventsByFilter(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatahubEventsByFilterResp(rsp)
}

// ListOrganizationsWithResponse request returning *ListOrganizationsResp
func (c *ClientWithResponses) ListOrganizationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrganizationsResp, error) {
	rsp, err := c.ListOrganizations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationsResp(rsp)
}

// ListRolesWithResponse request returning *ListRolesResp
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRolesResp, error) {
	rsp, err := c.ListRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResp(rsp)
}

// ListUsersWithResponse request returning *ListUsersResp
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResp, error) {
	rsp, err := c.ListUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResp(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResp
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResp, error) {
	rsp, err := c.InviteUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResp(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResp, error) {
	rsp, err := c.InviteUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResp(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResp
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserResp, error) {
	rsp, err := c.DeleteUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResp(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResp
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResp, error) {
	rsp, err := c.UpdateUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResp(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, id string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResp, error) {
	rsp, err := c.UpdateUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResp(rsp)
}

// GetResourcePermissionWithResponse request returning *GetResourcePermissionResp
func (c *ClientWithResponses) GetResourcePermissionWithResponse(ctx context.Context, resourceType GetResourcePermissionParamsResourceType, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourcePermissionResp, error) {
	rsp, err := c.GetResourcePermission(ctx, resourceType, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePermissionResp(rsp)
}

// UpdateResourcePermissionWithBodyWithResponse request with arbitrary body returning *UpdateResourcePermissionResp
func (c *ClientWithResponses) UpdateResourcePermissionWithBodyWithResponse(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourcePermissionResp, error) {
	rsp, err := c.UpdateResourcePermissionWithBody(ctx, resourceType, resourceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourcePermissionResp(rsp)
}

func (c *ClientWithResponses) UpdateResourcePermissionWithResponse(ctx context.Context, resourceType UpdateResourcePermissionParamsResourceType, resourceId ResourceId, body UpdateResourcePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourcePermissionResp, error) {
	rsp, err := c.UpdateResourcePermission(ctx, resourceType, resourceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourcePermissionResp(rsp)
}

// ListPlatformsWithResponse request returning *ListPlatformsResp
func (c *ClientWithResponses) ListPlatformsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlatformsResp, error) {
	rsp, err := c.ListPlatforms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlatformsResp(rsp)
}

// ListProductsWithResponse request returning *ListProductsResp
func (c *ClientWithResponses) ListProductsWithResponse(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*ListProductsResp, error) {
	rsp, err := c.ListProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductsResp(rsp)
}

// IdOfTicketsWithResponse request returning *IdOfTicketsResp
func (c *ClientWithResponses) IdOfTicketsWithResponse(ctx context.Context, params *IdOfTicketsParams, reqEditors ...RequestEditorFn) (*IdOfTicketsResp, error) {
	rsp, err := c.IdOfTickets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfTicketsResp(rsp)
}

// IdOfTicketsPostWithBodyWithResponse request with arbitrary body returning *IdOfTicketsPostResp
func (c *ClientWithResponses) IdOfTicketsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdOfTicketsPostResp, error) {
	rsp, err := c.IdOfTicketsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfTicketsPostResp(rsp)
}

func (c *ClientWithResponses) IdOfTicketsPostWithResponse(ctx context.Context, body IdOfTicketsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IdOfTicketsPostResp, error) {
	rsp, err := c.IdOfTicketsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdOfTicketsPostResp(rsp)
}

// ParseListAlertsResp parses an HTTP response from a ListAlertsWithResponse call
func ParseListAlertsResp(rsp *http.Response) (*ListAlertsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAlertsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalAlertList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAlertResp parses an HTTP response from a CreateAlertWithResponse call
func ParseCreateAlertResp(rsp *http.Response) (*CreateAlertResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAlertResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAlertResp parses an HTTP response from a DeleteAlertWithResponse call
func ParseDeleteAlertResp(rsp *http.Response) (*DeleteAlertResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAlertResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAlertResp parses an HTTP response from a GetAlertWithResponse call
func ParseGetAlertResp(rsp *http.Response) (*GetAlertResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAlertResp parses an HTTP response from a UpdateAlertWithResponse call
func ParseUpdateAlertResp(rsp *http.Response) (*UpdateAlertResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAlertResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAllocationsResp parses an HTTP response from a ListAllocationsWithResponse call
func ParseListAllocationsResp(rsp *http.Response) (*ListAllocationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllocationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Allocations *[]AllocationListItem `json:"allocations,omitempty"`

			// PageToken Page token, returned by a previous call, to request the next page of results.
			PageToken *string `json:"pageToken,omitempty"`

			// RowCount Total number of allocations in the result set.
			RowCount *int `json:"rowCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAllocationResp parses an HTTP response from a CreateAllocationWithResponse call
func ParseCreateAllocationResp(rsp *http.Response) (*CreateAllocationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAllocationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NewAllocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAllocationResp parses an HTTP response from a DeleteAllocationWithResponse call
func ParseDeleteAllocationResp(rsp *http.Response) (*DeleteAllocationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllocationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest []AllocationDeleteValidation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetAllocationResp parses an HTTP response from a GetAllocationWithResponse call
func ParseGetAllocationResp(rsp *http.Response) (*GetAllocationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllocationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Allocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAllocationResp parses an HTTP response from a UpdateAllocationWithResponse call
func ParseUpdateAllocationResp(rsp *http.Response) (*UpdateAllocationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAllocationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NewAllocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAnnotationsResp parses an HTTP response from a ListAnnotationsWithResponse call
func ParseListAnnotationsResp(rsp *http.Response) (*ListAnnotationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAnnotationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Annotations *[]AnnotationListItem `json:"annotations,omitempty"`

			// PageToken Page token, returned by a previous call, to request the next page of results
			PageToken *string `json:"pageToken,omitempty"`

			// RowCount Total number of annotations in the result set
			RowCount *int `json:"rowCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAnnotationResp parses an HTTP response from a CreateAnnotationWithResponse call
func ParseCreateAnnotationResp(rsp *http.Response) (*CreateAnnotationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAnnotationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AnnotationListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAnnotationResp parses an HTTP response from a DeleteAnnotationWithResponse call
func ParseDeleteAnnotationResp(rsp *http.Response) (*DeleteAnnotationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAnnotationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAnnotationResp parses an HTTP response from a GetAnnotationWithResponse call
func ParseGetAnnotationResp(rsp *http.Response) (*GetAnnotationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnnotationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnnotationListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAnnotationResp parses an HTTP response from a UpdateAnnotationWithResponse call
func ParseUpdateAnnotationResp(rsp *http.Response) (*UpdateAnnotationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAnnotationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnnotationListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAttributionGroupsResp parses an HTTP response from a ListAttributionGroupsWithResponse call
func ParseListAttributionGroupsResp(rsp *http.Response) (*ListAttributionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttributionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttributionGroupsListExternal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAttributionGroupResp parses an HTTP response from a CreateAttributionGroupWithResponse call
func ParseCreateAttributionGroupResp(rsp *http.Response) (*CreateAttributionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAttributionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAttributionGroupResp parses an HTTP response from a DeleteAttributionGroupWithResponse call
func ParseDeleteAttributionGroupResp(rsp *http.Response) (*DeleteAttributionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttributionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest []AttributionGroupDeleteValidation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetAttributionGroupResp parses an HTTP response from a GetAttributionGroupWithResponse call
func ParseGetAttributionGroupResp(rsp *http.Response) (*GetAttributionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttributionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttributionGroupGetExternal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttributionGroupResp parses an HTTP response from a UpdateAttributionGroupWithResponse call
func ParseUpdateAttributionGroupResp(rsp *http.Response) (*UpdateAttributionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttributionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAttributionsResp parses an HTTP response from a ListAttributionsWithResponse call
func ParseListAttributionsResp(rsp *http.Response) (*ListAttributionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttributionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Attributions Summary information for an attribution.
			Attributions *AttributionListItem `json:"Attributions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAttributionResp parses an HTTP response from a CreateAttributionWithResponse call
func ParseCreateAttributionResp(rsp *http.Response) (*CreateAttributionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAttributionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAttributionResp parses an HTTP response from a DeleteAttributionWithResponse call
func ParseDeleteAttributionResp(rsp *http.Response) (*DeleteAttributionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttributionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest []AttributionDeleteValidation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetAttributionResp parses an HTTP response from a GetAttributionWithResponse call
func ParseGetAttributionResp(rsp *http.Response) (*GetAttributionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttributionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Attribution Definition and metadata of an attribution.
			Attribution *AttributionAPI `json:"Attribution,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttributionResp parses an HTTP response from a UpdateAttributionWithResponse call
func ParseUpdateAttributionResp(rsp *http.Response) (*UpdateAttributionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttributionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBudgetsResp parses an HTTP response from a ListBudgetsWithResponse call
func ParseListBudgetsResp(rsp *http.Response) (*ListBudgetsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBudgetsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Budgets Array of Budgets
			Budgets *[]BudgetListItem `json:"budgets,omitempty"`

			// PageToken Page token, returned by a previous call, to request the next page of results
			PageToken *string `json:"pageToken,omitempty"`

			// RowCount Budgets rows count
			RowCount *int64 `json:"rowCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateBudgetResp parses an HTTP response from a CreateBudgetWithResponse call
func ParseCreateBudgetResp(rsp *http.Response) (*CreateBudgetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBudgetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BudgetAPI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteBudgetResp parses an HTTP response from a DeleteBudgetWithResponse call
func ParseDeleteBudgetResp(rsp *http.Response) (*DeleteBudgetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBudgetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBudgetResp parses an HTTP response from a GetBudgetWithResponse call
func ParseGetBudgetResp(rsp *http.Response) (*GetBudgetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetAPI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateBudgetResp parses an HTTP response from a UpdateBudgetWithResponse call
func ParseUpdateBudgetResp(rsp *http.Response) (*UpdateBudgetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBudgetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetAPI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCommitmentsResp parses an HTTP response from a ListCommitmentsWithResponse call
func ParseListCommitmentsResp(rsp *http.Response) (*ListCommitmentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommitmentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitmentExternalList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCommitmentResp parses an HTTP response from a GetCommitmentWithResponse call
func ParseGetCommitmentResp(rsp *http.Response) (*GetCommitmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommitmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitmentExternal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDimensionsResp parses an HTTP response from a GetDimensionsWithResponse call
func ParseGetDimensionsResp(rsp *http.Response) (*GetDimensionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDimensionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DimensionsExternalAPIGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDimensionsResp parses an HTTP response from a ListDimensionsWithResponse call
func ParseListDimensionsResp(rsp *http.Response) (*ListDimensionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDimensionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DimensionsExternalAPIList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListLabelsResp parses an HTTP response from a ListLabelsWithResponse call
func ParseListLabelsResp(rsp *http.Response) (*ListLabelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLabelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabelList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateLabelResp parses an HTTP response from a CreateLabelWithResponse call
func ParseCreateLabelResp(rsp *http.Response) (*CreateLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LabelListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteLabelResp parses an HTTP response from a DeleteLabelWithResponse call
func ParseDeleteLabelResp(rsp *http.Response) (*DeleteLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLabelResp parses an HTTP response from a GetLabelWithResponse call
func ParseGetLabelResp(rsp *http.Response) (*GetLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabelListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLabelResp parses an HTTP response from a UpdateLabelWithResponse call
func ParseUpdateLabelResp(rsp *http.Response) (*UpdateLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabelListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAssignObjectsToLabelResp parses an HTTP response from a AssignObjectsToLabelWithResponse call
func ParseAssignObjectsToLabelResp(rsp *http.Response) (*AssignObjectsToLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignObjectsToLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListReportsResp parses an HTTP response from a ListReportsWithResponse call
func ParseListReportsResp(rsp *http.Response) (*ListReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateReportResp parses an HTTP response from a CreateReportWithResponse call
func ParseCreateReportResp(rsp *http.Response) (*CreateReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id ID of the new report.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQueryResp parses an HTTP response from a QueryWithResponse call
func ParseQueryResp(rsp *http.Response) (*QueryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunReportResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReportResp parses an HTTP response from a DeleteReportWithResponse call
func ParseDeleteReportResp(rsp *http.Response) (*DeleteReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReportResp parses an HTTP response from a GetReportWithResponse call
func ParseGetReportResp(rsp *http.Response) (*GetReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreateTime The creation time of the report, in milliseconds since the epoch.
			CreateTime *int64 `json:"createTime,omitempty"`

			// Id Report ID.
			Id *string `json:"id,omitempty"`

			// Owner Email address of the report owner.
			Owner *string `json:"owner,omitempty"`

			// ReportName The name of the report.
			ReportName *string `json:"reportName,omitempty"`
			Result     *struct {
				// CacheHit If true, results were fetched from the cache.
				CacheHit     *bool                           `json:"cacheHit,omitempty"`
				ForecastRows *[][]Value                      `json:"forecastRows,omitempty"`
				MlFeatures   *[]GetReport200ResultMlFeatures `json:"mlFeatures,omitempty"`
				Rows         *[][]Value                      `json:"rows,omitempty"`
				Schema       *[]SchemaField                  `json:"schema,omitempty"`
			} `json:"result,omitempty"`
			Type *GetReport200Type `json:"type,omitempty"`

			// UpdateTime The time when this report was last updated, in milliseconds since the epoch.
			UpdateTime *int64 `json:"updateTime,omitempty"`

			// UrlUI The URL of the report in DoiT console.
			UrlUI *string `json:"urlUI,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdateReportResp parses an HTTP response from a UpdateReportWithResponse call
func ParseUpdateReportResp(rsp *http.Response) (*UpdateReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id ID of the updated report.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReportConfigResp parses an HTTP response from a GetReportConfigWithResponse call
func ParseGetReportConfigResp(rsp *http.Response) (*GetReportConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAnomaliesResp parses an HTTP response from a ListAnomaliesWithResponse call
func ParseListAnomaliesResp(rsp *http.Response) (*ListAnomaliesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAnomaliesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnomaliesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAnomalyResp parses an HTTP response from a GetAnomalyWithResponse call
func ParseGetAnomalyResp(rsp *http.Response) (*GetAnomalyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnomalyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Acknowledged Has the anomaly been acknowledged
			Acknowledged *bool `json:"acknowledged,omitempty"`

			// Attribution Attribution ID
			Attribution string `json:"attribution"`

			// BillingAccount Billing account ID
			BillingAccount string `json:"billingAccount"`

			// CostOfAnomaly The difference between the actual cost and the maximum cost in the normal range.
			CostOfAnomaly float64 `json:"costOfAnomaly"`

			// EndTime End of the anomaly
			EndTime *int `json:"endTime"`

			// Platform Cloud Provider name
			Platform string `json:"platform"`

			// ResourceData Array of resources contributing to an anomaly.
			ResourceData *AnomalyResourceArray `json:"resourceData,omitempty"`

			// Scope Scope: Project or Account
			Scope string `json:"scope"`

			// ServiceName Service name
			ServiceName string `json:"serviceName"`

			// SeverityLevel Severity level: Information, Warning or Critical
			SeverityLevel string `json:"severityLevel"`

			// StartTime Usage start time of the anomaly
			StartTime int64                `json:"startTime"`
			Status    *GetAnomaly200Status `json:"status"`

			// TimeFrame Timeframe: Daily or Hourly
			TimeFrame string `json:"timeFrame"`

			// Top3SKUs Array of SKU entries contributing to an anomaly.
			Top3SKUs AnomalySKUArray `json:"top3SKUs"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseValidateResp parses an HTTP response from a ValidateWithResponse call
func ParseValidateResp(rsp *http.Response) (*ValidateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseIdOfAssetsResp parses an HTTP response from a IdOfAssetsWithResponse call
func ParseIdOfAssetsResp(rsp *http.Response) (*IdOfAssetsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfAssetsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Assets Array of Assets
			Assets *[]AssetItem `json:"assets,omitempty"`

			// PageToken Page token. Can be used to request the next page of results.
			PageToken *string `json:"pageToken,omitempty"`

			// RowCount Assets rows count
			RowCount *int64 `json:"rowCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIdOfAssetResp parses an HTTP response from a IdOfAssetWithResponse call
func ParseIdOfAssetResp(rsp *http.Response) (*IdOfAssetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfAssetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id *string `json:"id,omitempty"`

			// Properties Additional properties associated with an asset.
			Properties *AssetProperties `json:"properties,omitempty"`
			Type       *string          `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAssetResp parses an HTTP response from a CreateAssetWithResponse call
func ParseCreateAssetResp(rsp *http.Response) (*CreateAssetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListInvoicesResp parses an HTTP response from a ListInvoicesWithResponse call
func ParseListInvoicesResp(rsp *http.Response) (*ListInvoicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Invoices Array of Invoices
			Invoices *[]InvoiceListItem `json:"invoices,omitempty"`

			// PageToken Page token. Can be used to request the next page of results.
			PageToken *string `json:"pageToken,omitempty"`

			// RowCount Invoice rows count
			RowCount *int64 `json:"rowCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInvoiceResp parses an HTTP response from a GetInvoiceWithResponse call
func ParseGetInvoiceResp(rsp *http.Response) (*GetInvoiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BalanceAmount Invoice balance to be paid
			BalanceAmount *float64 `json:"balanceAmount,omitempty"`

			// Currency Currency code for monetary values.
			Currency *Currency `json:"currency,omitempty"`

			// DueDate The last day to pay the invoice, in milliseconds since the epoch
			DueDate *int64 `json:"dueDate,omitempty"`

			// Id Invoice number, identifying the invoice.
			Id *string `json:"id,omitempty"`

			// InvoiceDate The time when this invoice was issued, in milliseconds since the epoch.
			InvoiceDate *int64 `json:"invoiceDate,omitempty"`

			// LineItems Invoice line items.
			LineItems *[]ListItem `json:"lineItems,omitempty"`

			// Platform Platform identifier for invoice source.
			Platform *InvoicePlatform `json:"platform,omitempty"`

			// Status Status of the invoice
			Status *GetInvoice200Status `json:"status,omitempty"`

			// TotalAmount Total invoiced amount
			TotalAmount *float64 `json:"totalAmount,omitempty"`

			// Url Link to [invoice details page](https://help.doit.com/docs/billing/invoices-and-payments/managing-invoices) in the DoiT console. You can download the PDF invoice from the invoice details page.
			Url *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindCloudDiagramsResp parses an HTTP response from a FindCloudDiagramsWithResponse call
func ParseFindCloudDiagramsResp(rsp *http.Response) (*FindCloudDiagramsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCloudDiagramsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindCloudDiagramsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListKnownIssuesResp parses an HTTP response from a ListKnownIssuesWithResponse call
func ParseListKnownIssuesResp(rsp *http.Response) (*ListKnownIssuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKnownIssuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Incidents Array of cloud incidents
			Incidents *[]CloudIncidentListItem `json:"incidents,omitempty"`

			// PageToken Page token, returned by a previous call, to request the next page of results
			PageToken *string `json:"pageToken,omitempty"`

			// RowCount Cloud incidents rows count
			RowCount *int64 `json:"rowCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetKnownIssueResp parses an HTTP response from a GetKnownIssueWithResponse call
func ParseGetKnownIssueResp(rsp *http.Response) (*GetKnownIssueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKnownIssueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreateTime The time when this cloud incident was created, in milliseconds since the epoch.
			CreateTime *int64 `json:"createTime,omitempty"`

			// Description Detailed explanation on the cloud incident.
			Description *string `json:"description,omitempty"`

			// Id The unique id of a cloud incident
			Id *string `json:"id,omitempty"`

			// Platform The cloud platform.
			Platform *GetKnownIssue200Platform `json:"platform,omitempty"`

			// Product The name of the product affected by the cloud incident
			Product *string `json:"product,omitempty"`

			// Status The Status of the issue
			Status *GetKnownIssue200Status `json:"status,omitempty"`

			// Summary A summary of the cloud incident.
			Summary *string `json:"summary,omitempty"`

			// Symptoms Cloud incident symptoms, if available.
			Symptoms *string `json:"symptoms,omitempty"`

			// Title Cloud incident name provided by the cloud vendor.
			Title *string `json:"title,omitempty"`

			// Workaround Mitigation workaround for the cloud incident, if available.
			Workaround *string `json:"workaround,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAccountTeamResp parses an HTTP response from a ListAccountTeamWithResponse call
func ParseListAccountTeamResp(rsp *http.Response) (*ListAccountTeamResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountTeamResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountManagers *[]AccountManagerListItem `json:"accountManagers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDatahubEventsCSVFileResp parses an HTTP response from a DatahubEventsCSVFileWithResponse call
func ParseDatahubEventsCSVFileResp(rsp *http.Response) (*DatahubEventsCSVFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatahubEventsCSVFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Batch batch id, generated during ingestion
			Batch *string `json:"batch,omitempty"`

			// IngestedRows the number of events that have been accepted for processing
			IngestedRows *int `json:"ingestedRows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDatahubEventsResp parses an HTTP response from a DatahubEventsWithResponse call
func ParseDatahubEventsResp(rsp *http.Response) (*DatahubEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatahubEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDatahubEventsByFilterResp parses an HTTP response from a DeleteDatahubEventsByFilterWithResponse call
func ParseDeleteDatahubEventsByFilterResp(rsp *http.Response) (*DeleteDatahubEventsByFilterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatahubEventsByFilterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOrganizationsResp parses an HTTP response from a ListOrganizationsWithResponse call
func ParseListOrganizationsResp(rsp *http.Response) (*ListOrganizationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRolesResp parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResp(rsp *http.Response) (*ListRolesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Roles *[]Role `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResp parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResp(rsp *http.Response) (*ListUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInviteUserResp parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResp(rsp *http.Response) (*InviteUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest InviteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResp parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResp(rsp *http.Response) (*DeleteUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResp parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResp(rsp *http.Response) (*UpdateUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePermissionResp parses an HTTP response from a GetResourcePermissionWithResponse call
func ParseGetResourcePermissionResp(rsp *http.Response) (*GetResourcePermissionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePermissionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePermissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateResourcePermissionResp parses an HTTP response from a UpdateResourcePermissionWithResponse call
func ParseUpdateResourcePermissionResp(rsp *http.Response) (*UpdateResourcePermissionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourcePermissionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePermissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPlatformsResp parses an HTTP response from a ListPlatformsWithResponse call
func ParseListPlatformsResp(rsp *http.Response) (*ListPlatformsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlatformsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Platforms *[]PlatformAPI `json:"platforms,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListProductsResp parses an HTTP response from a ListProductsWithResponse call
func ParseListProductsResp(rsp *http.Response) (*ListProductsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Products *[]ProductAPI `json:"products,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseIdOfTicketsResp parses an HTTP response from a IdOfTicketsWithResponse call
func ParseIdOfTicketsResp(rsp *http.Response) (*IdOfTicketsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfTicketsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TicketsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIdOfTicketsPostResp parses an HTTP response from a IdOfTicketsPostWithResponse call
func ParseIdOfTicketsPostResp(rsp *http.Response) (*IdOfTicketsPostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdOfTicketsPostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TicketResponseExtAPI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
